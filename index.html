<!DOCTYPE html>
<html lang="en">
<head>
    <title>Firebase Online Chess Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Bootstrap CSS & FontAwesome -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <script src="https://kit.fontawesome.com/5b14db5f0b.js" crossorigin="anonymous"></script>

    <!-- Chessboard.js CSS -->
    <link rel="stylesheet"
          href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
          crossorigin="anonymous">

    <!-- Custom CSS (Dark mode & nicer board colors) -->
    <style>
        :root{
            --bg: #0e1113;
            --panel: #0f1417;
            --muted: #9aa3a8;
            --accent: #6ee7b7;
            --light-square: #2f373b;
            --dark-square:  #1f2426;
            --highlight-move: #4b6bfb66;
            --highlight-capture: #fb6b6b66;
        }
        html,body{
            height:100%;
            background: linear-gradient(180deg,var(--bg), #071014 90%);
            color: #e7eef0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        }
        a { color: var(--accent); }
        .container.centered { margin-top: 48px; }
        .hidden { display: none !important; }
        .avatar {
            border-radius: 50%;
            width: 48px;
            height: 48px;
            object-fit: cover;
            border: 2px solid rgba(255,255,255,0.06);
            background: #0b0d0e;
        }
        #myBoard { margin: 12px auto; max-width: 480px; }
        /* chessboard squares (override chessboard.js default) */
        .white-1e1d7 { background-color: var(--light-square) !important; }
        .black-3c85d { background-color: var(--dark-square) !important; }
        /* highlight styles used by the original code */
        .highlight-white { box-shadow: inset 0 0 0 4px rgba(120,200,255,0.08); }
        .highlight-black { box-shadow: inset 0 0 0 4px rgba(160,120,255,0.08); }
        .highlight-hint { box-shadow: inset 0 0 0 4px rgba(120,255,180,0.08); }

        /* board container look */
        .board {
            border-radius: 8px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
            background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
            padding: 6px;
        }

        /* buttons */
        .btn { border-radius: 8px; }
        .btn-danger { background: #ef476f; border: none; }
        .btn-success { background: #06d6a0; border: none; color: #032b26; }
        .btn-secondary { background: #1f2a2c; border: none; color: #cfe9e2; }

        /* small responsive tweaks */
        @media (max-width: 767px) {
            #myBoard { max-width: 320px; }
            .avatar { width: 40px; height: 40px; }
        }

        /* modal custom */
        .modal-content {
            background: linear-gradient(180deg, #0b1113, #071014);
            color: #e6f7ef;
            border: 1px solid rgba(255,255,255,0.04);
        }
        .modal-header { border-bottom: 1px solid rgba(255,255,255,0.03); }
        .modal-footer { border-top: 1px solid rgba(255,255,255,0.03); }
    </style>
</head>
<body>
    <!-- Screens -->
    <!-- Login Screen -->
    <div id="login-screen" class="container centered">
        <h2>Sign in to Play Chess</h2>
        <button id="google-signin" class="btn btn-danger mt-4">
            <i class="fab fa-google"></i> Sign in with Google
        </button>
    </div>

    <!-- Home Screen -->
    <div id="home-screen" class="container centered hidden">
        <div>
            <img id="user-avatar" class="avatar mb-2" src="" alt="avatar">
            <div style="margin-top:8px;">Welcome, <span id="user-name"></span></div>
        </div>
        <button id="start-game-btn" class="btn btn-success mt-4">Start Game</button>
        <button id="logout-btn" class="btn btn-secondary ml-2">Logout</button>
    </div>

    <!-- Waiting Screen -->
    <div id="waiting-screen" class="container centered hidden">
        <h3>Waiting for another player...</h3>
        <div class="spinner-border mt-3" role="status"></div>
        <p class="mt-4">If you wait too long, you can <button id="cancel-wait" class="btn btn-link">cancel</button>.</p>
    </div>

    <!-- Chess Game Screen -->
    <div id="game-screen" class="container hidden">
        <div class="row my-3">
            <div class="col-12 text-center">
                <h3 id="game-title">Chess Match</h3>
                <div id="match-status" style="margin-top:6px;color:var(--muted);"></div>
            </div>
        </div>
        <div class="row align-items-center">
            <div class="col-md-6">
                <div class="mb-2">
                    <span><img id="white-avatar" class="avatar" src=""> <b id="white-name"></b> (White)</span>
                </div>
                <div class="mb-2">
                    <span><img id="black-avatar" class="avatar" src=""> <b id="black-name"></b> (Black)</span>
                </div>
                <div id="gameStatus" class="my-2"></div>
                <div class="mt-2">
                    <button id="resign-btn" class="btn btn-danger">Resign</button>
                    <button id="abort-btn" class="btn btn-secondary ml-2">Abort</button>
                </div>
            </div>
            <div class="col-md-6">
                <div id="myBoard"></div>
            </div>
        </div>
    </div>

    <!-- Result Modal (shown when opponent resigns/aborts or game ended with a reason) -->
    <div class="modal fade" id="resultModal" tabindex="-1" role="dialog" aria-labelledby="resultModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 id="resultModalLabel" class="modal-title">Game Result</h5>
            <button type="button" class="close text-light" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body" id="resultModalBody">
            <!-- Filled dynamically -->
          </div>
          <div class="modal-footer">
            <button type="button" id="resultModalOk" class="btn btn-success" data-dismiss="modal">OK</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Firebase & Dependencies -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>

    <!-- Bootstrap JS (for modal) -->
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js"></script>

    <!-- Chessboard.js -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
        crossorigin="anonymous"></script>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

    <!-- Chess.js (local file, must be present in same directory) -->
    <script src="js/chess.js"></script>

    <script>
    // ----------------- CONFIGURE THIS SECTION -------------------
    // Replace with your Firebase project config (already in your file).
    const firebaseConfig = {
        apiKey: "AIzaSyD8z3e5j9y48wJkyU89F7M19cDfxQ4P8uo",
        authDomain: "chess-online-ebc1f.firebaseapp.com",
        databaseURL: "https://chess-online-ebc1f-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "chess-online-ebc1f",
        storageBucket: "chess-online-ebc1f.firebasestorage.app",
        messagingSenderId: "825068912703",
        appId: "1:825068912703:web:48330509c612b8b4cdf88a"
    };
    // ------------------------------------------------------------

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    // ---- UI Screen helpers ----
    function showScreen(screen) {
        $('#login-screen, #home-screen, #waiting-screen, #game-screen').addClass('hidden');
        $(`#${screen}`).removeClass('hidden');
    }

    // ---- Auth ----
    let currentUser = null;
    auth.onAuthStateChanged(user => {
        currentUser = user;
        if (user) {
            $('#user-avatar').attr('src', user.photoURL);
            $('#user-name').text(user.displayName);
            showScreen('home-screen');
        } else {
            showScreen('login-screen');
        }
    });

    $('#google-signin').on('click', function() {
        const provider = new firebase.auth.GoogleAuthProvider();
        auth.signInWithPopup(provider);
    });

    $('#logout-btn').on('click', function() {
        auth.signOut();
    });

    // ---- Game Matching Logic ----
    let waitingRef = db.ref('waiting');
    let gamesRef = db.ref('games');
    let myGameId = null;
    let myColor = null;
    let gameListener = null;
    let board = null;
    let chess = null;
    let opponent = null;

    $('#start-game-btn').on('click', function() {
        // Add self to waiting, but check for race condition
        showScreen('waiting-screen');
        waitingRef.transaction(waiting => {
            if (!waiting) waiting = [];
            if (!waiting.includes(currentUser.uid)) waiting.push(currentUser.uid);
            return waiting;
        });
        tryMatchPlayers();
    });

    // Cancel waiting (remove self from waiting list)
    $('#cancel-wait').on('click', function() {
        waitingRef.transaction(waiting => {
            if (!waiting) return [];
            return waiting.filter(uid => uid !== currentUser.uid);
        });
        showScreen('home-screen');
    });

    // Try to match players atomically
    function tryMatchPlayers() {
        waitingRef.on('value', function(snapshot) {
            let waiting = snapshot.val() || [];
            if (waiting.length >= 2) {
                // Atomically pop two players and create a match
                waitingRef.transaction(waitingList => {
                    if (!waitingList || waitingList.length < 2) return waitingList;
                    // Get two players who are not already in a game
                    let [p1, p2] = waitingList.slice(0,2);
                    // Only proceed if current user is one of them
                    if (![p1, p2].includes(currentUser.uid)) return waitingList;
                    let remaining = waitingList.filter(uid => uid !== p1 && uid !== p2);
                    // Create a new game
                    let gameId = gamesRef.push().key;
                    let white = Math.random() < 0.5 ? p1 : p2;
                    let black = (white === p1 ? p2 : p1);
                    let gameData = {
                        id: gameId,
                        white: { uid: white },
                        black: { uid: black },
                        fen: 'start',
                        turn: 'w',
                        status: 'playing',
                        lastUpdate: firebase.database.ServerValue.TIMESTAMP
                    };
                    let updates = {};
                    updates['games/' + gameId] = gameData;
                    updates['waiting'] = remaining;
                    db.ref().update(updates);
                    return remaining;
                });
            }
        });
        // Listen for a game assigned to us
        listenForMatch();
    }

    function listenForMatch() {
        // Remove previous listeners
        if (gameListener) gamesRef.off('child_added', gameListener);
        gameListener = gamesRef.orderByChild('status').equalTo('playing').on('child_added', function(snapshot) {
            let data = snapshot.val();
            if (!data) return;
            if ([data.white.uid, data.black.uid].includes(currentUser.uid)) {
                // Both players will immediately go to game
                startGame(snapshot.key, data);
            }
        });
    }

    function startGame(gameId, data) {
        myGameId = gameId;
        myColor = (data.white.uid === currentUser.uid) ? 'w' : 'b';
        let opponentUid = (myColor === 'w') ? data.black.uid : data.white.uid;
        // Get opponent info
        db.ref('users/' + opponentUid).once('value').then(snap => {
            opponent = snap.val();
            // Fallback if user profile doesn't exist
            if (!opponent) opponent = { displayName: 'Opponent', photoURL: '' };
            showMatch(data);
        });
    }

    // Store player info on login
    auth.onAuthStateChanged(user => {
        if (user) {
            db.ref('users/' + user.uid).set({
                displayName: user.displayName,
                photoURL: user.photoURL
            });
        }
    });

    // ------------- Chess Game UI and Logic -----------------
    function showMatch(data) {
        // Set player names and avatars
        db.ref('users/' + data.white.uid).once('value').then(snap => {
            let white = snap.val() || { displayName: 'White', photoURL: '' };
            $('#white-name').text(white.displayName);
            $('#white-avatar').attr('src', white.photoURL);
        });
        db.ref('users/' + data.black.uid).once('value').then(snap => {
            let black = snap.val() || { displayName: 'Black', photoURL: '' };
            $('#black-name').text(black.displayName);
            $('#black-avatar').attr('src', black.photoURL);
        });

        showScreen('game-screen');
        $('#gameStatus').text('');
        $('#match-status').text('You are playing as ' + (myColor === 'w' ? 'White' : 'Black'));

        // Chessboard
        if (board) {
            board.destroy();
        }
        chess = new Chess();
        if (data.fen && data.fen !== 'start') chess.load(data.fen);

        board = Chessboard('myBoard', {
            draggable: true,
            orientation: (myColor === 'w' ? 'white' : 'black'),
            position: data.fen === 'start' ? 'start' : data.fen,
            pieceTheme: function(piece) {
                // piece is like 'wK', 'bQ'
                return 'pieces/' + piece + '.svg';
            },
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd
        });

        // Listen for game updates
        gamesRef.child(myGameId).on('value', function(snapshot) {
            let gameData = snapshot.val();
            if (!gameData) {
                // game deleted
                // treat as abort (if we still have myGameId) to avoid confusion
                if (myGameId) {
                    showResultModal({ type: 'abort', by: null, info: 'Game removed' });
                    cleanupAfterGame();
                }
                return;
            }

            // If ended with a result, show a modal describing the reason (resign/abort)
            if (gameData.status === 'ended') {
                if (gameData.result) {
                    showResultModal(gameData.result);
                } else {
                    $('#gameStatus').text('Game Ended');
                }
                // update board to final position if provided
                if (gameData.fen) {
                    chess.load(gameData.fen);
                    board.position(gameData.fen === 'start' ? 'start' : gameData.fen);
                }
                // remove realtime listener for this game (we keep data in DB so opponent can see modal)
                gamesRef.child(myGameId).off();
                // cleanup local state after letting user see modal
                cleanupAfterGame();
                return;
            }

            // Update board if FEN changes
            if (chess.fen() !== gameData.fen && gameData.fen) {
                chess.load(gameData.fen);
                board.position(gameData.fen === 'start' ? 'start' : gameData.fen);
            }
            updateStatus();
        });

        // Hook up resign/abort buttons
        $('#resign-btn').off('click').on('click', function() {
            if (!myGameId) return;
            // mark game ended with resign reason and winner = opponent
            gamesRef.child(myGameId).once('value').then(snap => {
                let d = snap.val();
                if (!d) return;
                let opponentUid = (d.white.uid === currentUser.uid) ? d.black.uid : d.white.uid;
                let result = {
                    type: 'resign',
                    by: currentUser.uid,
                    winner: opponentUid,
                    info: (currentUser.displayName || 'A player') + ' resigned'
                };
                gamesRef.child(myGameId).update({
                    status: 'ended',
                    result: result,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
                // show immediate local modal for clarity
                showResultModal(result);
                // cleanup local after modal
                cleanupAfterGame();
            });
        });

        $('#abort-btn').off('click').on('click', function() {
            if (!myGameId) return;
            gamesRef.child(myGameId).once('value').then(snap => {
                let d = snap.val();
                if (!d) return;
                let opponentUid = (d.white.uid === currentUser.uid) ? d.black.uid : d.white.uid;
                let result = {
                    type: 'abort',
                    by: currentUser.uid,
                    winner: null,
                    info: (currentUser.displayName || 'A player') + ' aborted the game'
                };
                gamesRef.child(myGameId).update({
                    status: 'ended',
                    result: result,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
                showResultModal(result);
                cleanupAfterGame();
            });
        });
    }

    // Chessboard.js handlers
    function onDragStart(source, piece, position, orientation) {
        // Only allow drag if it's your turn and your piece
        if (chess.game_over()) return false;
        if ((chess.turn() === 'w' && myColor !== 'w') || (chess.turn() === 'b' && myColor !== 'b')) {
            return false;
        }
        if ((myColor === 'w' && piece.search(/^w/) === -1) || (myColor === 'b' && piece.search(/^b/) === -1)) {
            return false;
        }
    }

    function onDrop(source, target) {
        let move = chess.move({
            from: source,
            to: target,
            promotion: 'q'
        });
        if (move === null) return 'snapback';

        // Update in DB, but only one update at a time to avoid overwriting
        let update = {
            fen: chess.fen(),
            turn: chess.turn(),
            lastUpdate: firebase.database.ServerValue.TIMESTAMP
        };
        // Check game end
        if (chess.game_over()) {
            update.status = "ended";
            update.result = {
                type: 'game_over',
                by: null,
                winner: null,
                info: 'Game finished (checkmate/draw/stalemate)'
            };
        }
        gamesRef.child(myGameId).update(update);
        updateStatus();
    }

    function onSnapEnd() {
        board.position(chess.fen());
    }

    function updateStatus() {
        let status = "";
        if (chess.in_checkmate()) {
            status = "Checkmate! " + (chess.turn() === 'w' ? "Black" : "White") + " wins.";
        } else if (chess.in_draw()) {
            status = "Draw!";
        } else if (chess.in_stalemate()) {
            status = "Stalemate!";
        } else if (chess.in_check()) {
            status = "Check!";
        } else {
            status = (chess.turn() === myColor) ? "Your turn" : "Opponent's turn";
        }
        $('#gameStatus').text(status);
    }

    // Show a friendly modal when game ended by resign/abort/other
    function showResultModal(result) {
        let body = '';
        if (!result) {
            body = 'Game ended.';
        } else if (result.type === 'resign') {
            if (result.by === currentUser.uid) {
                body = 'You resigned. You lost the game.';
            } else {
                body = 'Your opponent resigned. You win!';
            }
        } else if (result.type === 'abort') {
            if (result.by === currentUser.uid) {
                body = 'You aborted the game.';
            } else {
                body = 'Your opponent aborted the game.';
            }
        } else if (result.type === 'game_over') {
            body = result.info || 'Game finished.';
        } else {
            // generic
            body = result.info || 'Game ended.';
        }
        $('#resultModalBody').text(body);
        $('#resultModal').modal({backdrop: 'static', keyboard: false});
    }

    // Cleanup local state after a match finishes (keep DB entry so opponent sees modal)
    function cleanupAfterGame() {
        myGameId = null;
        myColor = null;
        chess = null;
        if (board) {
            board.destroy();
            board = null;
        }
        // Return to home screen after small delay so user sees modal
        setTimeout(function() {
            showScreen('home-screen');
        }, 300);
    }

    // If user closes window while in a game, attempt to mark as abort (best-effort)
    window.addEventListener('beforeunload', function(e) {
        if (myGameId && currentUser) {
            try {
                let result = {
                    type: 'abort',
                    by: currentUser.uid,
                    winner: null,
                    info: (currentUser.displayName || 'A player') + ' disconnected'
                };
                gamesRef.child(myGameId).update({
                    status: 'ended',
                    result: result,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
            } catch (err) {
                // nothing to do; best-effort
            }
            waitingRef.transaction(waiting => {
                if (!waiting) return [];
                return waiting.filter(uid => uid !== (currentUser && currentUser.uid));
            });
        } else {
            waitingRef.transaction(waiting => {
                if (!waiting) return [];
                return waiting.filter(uid => uid !== (currentUser && currentUser.uid));
            });
        }
    });

    auth.onAuthStateChanged(user => {
        if (!user && myGameId) {
            // if signed out, try to mark abort so opponent isn't surprised
            try {
                let result = {
                    type: 'abort',
                    by: currentUser ? currentUser.uid : null,
                    winner: null,
                    info: 'Player signed out'
                };
                gamesRef.child(myGameId).update({
                    status: 'ended',
                    result: result,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
            } catch (err) {}
            cleanupAfterGame();
        }
    });
    </script>
</body>
		  </html>
