<!DOCTYPE html>
<html lang="en">
<head>
    <title>Firebase Online Chess Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Bootstrap CSS & FontAwesome -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <script src="https://kit.fontawesome.com/5b14db5f0b.js" crossorigin="anonymous"></script>

    <!-- Chessboard.js CSS -->
    <link rel="stylesheet"
          href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
          crossorigin="anonymous">

    <!-- Custom CSS (Dark mode & nicer board colors, scroll fixed, clock, toggle) -->
    <style>
        :root{
            --bg: #0e1113;
            --panel: #0f1417;
            --muted: #9aa3a8;
            --accent: #6ee7b7;
            --light-square: #2f373b;
            --dark-square:  #1f2426;
            --highlight-move: #4b6bfb66;
            --highlight-capture: #fb6b6b66;
        }
        html,body{
            height:100%;
            background: linear-gradient(180deg,var(--bg), #071014 90%);
            color: #e7eef0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            overflow-x: hidden;
        }
        a { color: var(--accent); }
        .container.centered { margin-top: 48px; }
        .hidden { display: none !important; }
        .avatar {
            border-radius: 50%;
            width: 48px;
            height: 48px;
            object-fit: cover;
            border: 2px solid rgba(255,255,255,0.06);
            background: #0b0d0e;
        }
        #myBoard {
            margin: 12px auto;
            max-width: 380px;
            max-height: 380px;
            touch-action: none;
            user-select: none;
        }
        /* chessboard squares (override chessboard.js default) */
        .white-1e1d7 { background-color: var(--light-square) !important; }
        .black-3c85d { background-color: var(--dark-square) !important; }
        .highlight-white { box-shadow: inset 0 0 0 4px rgba(120,200,255,0.08); }
        .highlight-black { box-shadow: inset 0 0 0 4px rgba(160,120,255,0.08); }
        .highlight-hint { box-shadow: inset 0 0 0 4px rgba(120,255,180,0.08); }
        .square-selected { outline: 2.5px solid var(--accent) !important; z-index: 10; }

        /* board container look */
        .board {
            border-radius: 8px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
            background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
            padding: 6px;
        }
        .btn { border-radius: 8px; }
        .btn-danger { background: #ef476f; border: none; }
        .btn-success { background: #06d6a0; border: none; color: #032b26; }
        .btn-secondary { background: #1f2a2c; border: none; color: #cfe9e2; }
        @media (max-width: 767px) {
            #myBoard { max-width: 98vw; max-height: 98vw; }
            .avatar { width: 40px; height: 40px; }
            html,body { overflow-x: hidden; }
        }
        /* modal custom */
        .modal-content {
            background: linear-gradient(180deg, #0b1113, #071014);
            color: #e6f7ef;
            border: 1px solid rgba(255,255,255,0.04);
        }
        .modal-header { border-bottom: 1px solid rgba(255,255,255,0.03); }
        .modal-footer { border-top: 1px solid rgba(255,255,255,0.03); }

        /* Clock style */
        .chess-clock {
            font-size: 1.35rem;
            font-family: "Roboto Mono", monospace;
            font-weight: bold;
            background: #1f2a2c;
            border-radius: 9px;
            padding: 7px 16px 7px 16px;
            margin: 0 0 8px 0;
            color: #e7eef0;
            min-width: 110px;
            letter-spacing: 1px;
            display: inline-block;
        }
        .chess-clock.active {
            background: #212726;
            color: #6ee7b7;
            box-shadow: 0 0 10px 2px #37d6b2b0;
        }
        .chess-clock.timeout {
            background: #ef476f;
            color: #fff;
        }

        /* Time mode toggle */
        .toggle-btn-group {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 18px 0 0 0;
        }
        .toggle-btn {
            padding: 10px 26px;
            font-size: 1.08rem;
            border: none;
            background: #232e2f;
            color: #cfe9e2;
            border-radius: 16px;
            outline: none;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            font-weight: 500;
        }
        .toggle-btn.selected, .toggle-btn:active {
            background: #6ee7b7;
            color: #032b26;
        }
        /* Responsive fix: don't let any container scroll */
        .container {
            overflow: visible !important;
        }
        body, html {
            overscroll-behavior: none;
        }
    </style>
</head>
<body>
    <!-- Screens -->
    <!-- Login Screen -->
    <div id="login-screen" class="container centered">
        <h2>Sign in to Play Chess</h2>
        <button id="google-signin" class="btn btn-danger mt-4">
            <i class="fab fa-google"></i> Sign in with Google
        </button>
    </div>

    <!-- Home Screen -->
    <div id="home-screen" class="container centered hidden">
        <div>
            <img id="user-avatar" class="avatar mb-2" src="" alt="avatar">
            <div style="margin-top:8px;">Welcome, <span id="user-name"></span></div>
        </div>
        <div class="toggle-btn-group">
            <button class="toggle-btn selected" id="blitz-btn" data-mode="blitz">Blitz</button>
            <button class="toggle-btn" id="rapid-btn" data-mode="rapid">Rapid</button>
        </div>
        <button id="start-game-btn" class="btn btn-success mt-4">Start Game</button>
        <button id="logout-btn" class="btn btn-secondary ml-2">Logout</button>
    </div>

    <!-- Waiting Screen -->
    <div id="waiting-screen" class="container centered hidden">
        <h3>Waiting for another player...</h3>
        <div class="spinner-border mt-3" role="status"></div>
        <p class="mt-4">If you wait too long, you can <button id="cancel-wait" class="btn btn-link">cancel</button>.</p>
    </div>

    <!-- Chess Game Screen -->
    <div id="game-screen" class="container hidden">
        <div class="row my-3">
            <div class="col-12 text-center">
                <h3 id="game-title">Chess Match</h3>
                <div id="match-status" style="margin-top:6px;color:var(--muted);"></div>
            </div>
        </div>
        <div class="row align-items-center">
            <div class="col-md-6 d-flex flex-column align-items-center" style="gap: 0.8rem;">
                <div>
                    <span><img id="white-avatar" class="avatar" src=""> <b id="white-name"></b> (White)</span>
                </div>
                <div>
                    <span><img id="black-avatar" class="avatar" src=""> <b id="black-name"></b> (Black)</span>
                </div>
                <div class="mt-2 mb-1 d-flex flex-row align-items-center" style="gap: 12px;">
                    <span id="white-clock" class="chess-clock">05:00</span>
                    <span id="black-clock" class="chess-clock">05:00</span>
                </div>
                <div id="gameStatus" class="my-2"></div>
                <div class="mt-2">
                    <button id="resign-btn" class="btn btn-danger">Resign</button>
                    <button id="abort-btn" class="btn btn-secondary ml-2">Abort</button>
                </div>
            </div>
            <div class="col-md-6 d-flex justify-content-center align-items-center">
                <div id="myBoard"></div>
            </div>
        </div>
    </div>

    <!-- Result Modal (shown when opponent resigns/aborts, timeout, or game ended with a reason) -->
    <div class="modal fade" id="resultModal" tabindex="-1" role="dialog" aria-labelledby="resultModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 id="resultModalLabel" class="modal-title">Game Result</h5>
            <button type="button" class="close text-light" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body" id="resultModalBody">
            <!-- Filled dynamically -->
          </div>
          <div class="modal-footer">
            <button type="button" id="resultModalOk" class="btn btn-success" data-dismiss="modal">OK</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Firebase & Dependencies -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- Bootstrap JS (for modal) -->
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js"></script>
    <!-- Chessboard.js -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
        crossorigin="anonymous"></script>
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <!-- Chess.js (local file, must be present in same directory) -->
    <script src="js/chess.js"></script>
    <script>
    // ----------------- CONFIGURE THIS SECTION -------------------
    const firebaseConfig = {
        apiKey: "AIzaSyD8z3e5j9y48wJkyU89F7M19cDfxQ4P8uo",
        authDomain: "chess-online-ebc1f.firebaseapp.com",
        databaseURL: "https://chess-online-ebc1f-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "chess-online-ebc1f",
        storageBucket: "chess-online-ebc1f.firebasestorage.app",
        messagingSenderId: "825068912703",
        appId: "1:825068912703:web:48330509c612b8b4cdf88a"
    };
    // ------------------------------------------------------------

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    // ---- UI Screen helpers ----
    function showScreen(screen) {
        $('#login-screen, #home-screen, #waiting-screen, #game-screen').addClass('hidden');
        $(`#${screen}`).removeClass('hidden');
    }

    // ---- Auth ----
    let currentUser = null;
    auth.onAuthStateChanged(user => {
        currentUser = user;
        if (user) {
            $('#user-avatar').attr('src', user.photoURL);
            $('#user-name').text(user.displayName);
            showScreen('home-screen');
        } else {
            showScreen('login-screen');
        }
    });

    $('#google-signin').on('click', function() {
        const provider = new firebase.auth.GoogleAuthProvider();
        auth.signInWithPopup(provider);
    });

    $('#logout-btn').on('click', function() {
        auth.signOut();
    });

    // Time control (toggle and init)
    let selectedMode = 'blitz'; // default
    let timeSettings = { blitz: 5 * 60, rapid: 10 * 60 }; // seconds

    $('#blitz-btn').on('click', function() {
        selectedMode = 'blitz';
        $('#blitz-btn').addClass('selected');
        $('#rapid-btn').removeClass('selected');
    });
    $('#rapid-btn').on('click', function() {
        selectedMode = 'rapid';
        $('#rapid-btn').addClass('selected');
        $('#blitz-btn').removeClass('selected');
    });

    // ---- Game Matching Logic ----
    let waitingRef = db.ref('waiting');
    let gamesRef = db.ref('games');
    let myGameId = null;
    let myColor = null;
    let board = null;
    let chess = null;
    let opponent = null;
    let myClockInterval = null;
    let clock = { w: 0, b: 0, wLast: null, bLast: null, running: false, winner: null };
    let lastMoveTime = null;
    let gameListener = null;

    $('#start-game-btn').on('click', function() {
        // Add self to waiting, include selectedMode
        showScreen('waiting-screen');
        waitingRef.transaction(waiting => {
            if (!waiting) waiting = [];
            // remove any old entry of mine (if any)
            waiting = waiting.filter(uid => typeof uid !== "object" ? uid !== currentUser.uid : uid.uid !== currentUser.uid);
            waiting.push({uid: currentUser.uid, mode: selectedMode});
            return waiting;
        });
        tryMatchPlayers();
    });

    // Cancel waiting (remove self from waiting list)
    $('#cancel-wait').on('click', function() {
        waitingRef.transaction(waiting => {
            if (!waiting) return [];
            return waiting.filter(item =>
                (typeof item === "object" ? item.uid !== currentUser.uid : item !== currentUser.uid)
            );
        });
        showScreen('home-screen');
    });

    // Try to match players atomically (match same mode only)
    function tryMatchPlayers() {
        waitingRef.on('value', function(snapshot) {
            let waiting = snapshot.val() || [];
            let myObj = waiting.find(item =>
                typeof item === "object" ? item.uid === currentUser.uid : item === currentUser.uid
            );
            if (!myObj) return;
            let mode = myObj.mode || selectedMode;
            let pair = waiting.filter(item => typeof item === "object" && item.mode === mode);
            if (pair.length >= 2) {
                waitingRef.transaction(waitingList => {
                    if (!waitingList) return waitingList;
                    let available = waitingList.filter(item => typeof item === "object" && item.mode === mode);
                    if (available.length < 2) return waitingList;
                    let [p1, p2] = available;
                    if (![p1.uid, p2.uid].includes(currentUser.uid)) return waitingList;
                    let remaining = waitingList.filter(
                        item => !(typeof item === "object" && [p1.uid, p2.uid].includes(item.uid) && item.mode === mode)
                    );
                    // Create a new game
                    let gameId = gamesRef.push().key;
                    let white = Math.random() < 0.5 ? p1.uid : p2.uid;
                    let black = (white === p1.uid ? p2.uid : p1.uid);
                    let timeInit = timeSettings[mode];
                    let gameData = {
                        id: gameId,
                        white: { uid: white },
                        black: { uid: black },
                        fen: 'start',
                        turn: 'w',
                        status: 'playing',
                        mode: mode,
                        clock: { w: timeInit, b: timeInit, running: true, winner: null, last: Date.now() },
                        lastUpdate: firebase.database.ServerValue.TIMESTAMP
                    };
                    let updates = {};
                    updates['games/' + gameId] = gameData;
                    updates['waiting'] = remaining;
                    db.ref().update(updates);
                    return remaining;
                });
            }
        });
        listenForMatch();
    }

    function listenForMatch() {
        if (gameListener) gamesRef.off('child_added', gameListener);
        gameListener = gamesRef.orderByChild('status').equalTo('playing').on('child_added', function(snapshot) {
            let data = snapshot.val();
            if (!data) return;
            if ([data.white.uid, data.black.uid].includes(currentUser.uid)) {
                startGame(snapshot.key, data);
            }
        });
    }

    function startGame(gameId, data) {
        myGameId = gameId;
        myColor = (data.white.uid === currentUser.uid) ? 'w' : 'b';
        let opponentUid = (myColor === 'w') ? data.black.uid : data.white.uid;
        // Get opponent info
        db.ref('users/' + opponentUid).once('value').then(snap => {
            opponent = snap.val();
            if (!opponent) opponent = { displayName: 'Opponent', photoURL: '' };
            showMatch(data);
        });
    }

    // Store player info on login
    auth.onAuthStateChanged(user => {
        if (user) {
            db.ref('users/' + user.uid).set({
                displayName: user.displayName,
                photoURL: user.photoURL
            });
        }
    });

    // ------------ Click-to-move + Chessboard logic -------------
    // Click-to-move: allow clicking squares to make moves
    let squareSelected = null;
    let legalSquares = [];

    function enableClickToMove() {
        $('#myBoard .square-55d63').off('click').on('click', function (e) {
            let square = $(this).attr('data-square');
            if (!square) return;
            if (!squareSelected) {
                // Select only if my turn and my piece
                let piece = chess.get(square);
                if (piece && piece.color === myColor && chess.turn() === myColor && !chess.game_over()) {
                    squareSelected = square;
                    highlightSquare(squareSelected);
                    // Show legal moves from this square
                    legalSquares = chess.moves({ square: square, verbose: true }).map(m => m.to);
                    highlightSquares(legalSquares);
                }
            } else {
                if (square === squareSelected) {
                    // Deselect
                    removeAllHighlights();
                    squareSelected = null;
                    legalSquares = [];
                } else if (legalSquares.includes(square)) {
                    // Make move
                    removeAllHighlights();
                    let move = chess.move({ from: squareSelected, to: square, promotion: 'q' });
                    if (move == null) {
                        squareSelected = null;
                        legalSquares = [];
                        return;
                    }
                    // Send move to DB
                    updateMoveToDB(chess.fen());
                    squareSelected = null;
                    legalSquares = [];
                } else {
                    // New select if own piece
                    let piece = chess.get(square);
                    if (piece && piece.color === myColor && chess.turn() === myColor && !chess.game_over()) {
                        removeAllHighlights();
                        squareSelected = square;
                        highlightSquare(squareSelected);
                        legalSquares = chess.moves({ square: square, verbose: true }).map(m => m.to);
                        highlightSquares(legalSquares);
                    }
                }
            }
        });
    }
    function highlightSquare(sq) {
        $('#myBoard .square-' + sq).addClass('square-selected');
    }
    function highlightSquares(sqs) {
        for (let sq of sqs) {
            $('#myBoard .square-' + sq).addClass('highlight-hint');
        }
    }
    function removeAllHighlights() {
        $('#myBoard .square-55d63').removeClass('square-selected highlight-hint');
    }

    // ------------- Chess Game UI and Logic -----------------
    function showMatch(data) {
        // Set player names and avatars
        db.ref('users/' + data.white.uid).once('value').then(snap => {
            let white = snap.val() || { displayName: 'White', photoURL: '' };
            $('#white-name').text(white.displayName);
            $('#white-avatar').attr('src', white.photoURL);
        });
        db.ref('users/' + data.black.uid).once('value').then(snap => {
            let black = snap.val() || { displayName: 'Black', photoURL: '' };
            $('#black-name').text(black.displayName);
            $('#black-avatar').attr('src', black.photoURL);
        });

        showScreen('game-screen');
        $('#gameStatus').text('');
        $('#match-status').text('You are playing as ' + (myColor === 'w' ? 'White' : 'Black') +
            " â€¢ " + (data.mode === 'blitz' ? 'Blitz (5 min)' : 'Rapid (10 min)'));

        // Chessboard
        if (board) board.destroy();
        chess = new Chess();
        if (data.fen && data.fen !== 'start') chess.load(data.fen);

        board = Chessboard('myBoard', {
            draggable: true,
            orientation: (myColor === 'w' ? 'white' : 'black'),
            position: data.fen === 'start' ? 'start' : data.fen,
            pieceTheme: function(piece) {
                return 'pieces/' + piece + '.svg';
            },
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd
        });

        setTimeout(enableClickToMove, 400); // Wait for board render

        // Initialize clocks
        let initW = (data.clock && data.clock.w) || timeSettings[data.mode];
        let initB = (data.clock && data.clock.b) || timeSettings[data.mode];
        updateClockUI(initW, initB, data.turn);

        // Listen for game updates
        gamesRef.child(myGameId).on('value', function(snapshot) {
            let gameData = snapshot.val();
            if (!gameData) {
                if (myGameId) {
                    showResultModal({ type: 'abort', by: null, info: 'Game removed' });
                    cleanupAfterGame();
                }
                return;
            }
            // Clock: update UI tick
            if (gameData.clock) {
                updateClockUI(gameData.clock.w, gameData.clock.b, gameData.turn, gameData.clock.winner);
            }
            // Ended?
            if (gameData.status === 'ended') {
                if (gameData.result) {
                    showResultModal(gameData.result);
                } else {
                    $('#gameStatus').text('Game Ended');
                }
                if (gameData.fen) {
                    chess.load(gameData.fen);
                    board.position(gameData.fen === 'start' ? 'start' : gameData.fen);
                }
                gamesRef.child(myGameId).off();
                cleanupAfterGame();
                return;
            }
            // Board update
            if (chess.fen() !== gameData.fen && gameData.fen) {
                chess.load(gameData.fen);
                board.position(gameData.fen === 'start' ? 'start' : gameData.fen);
                removeAllHighlights();
            }
            updateStatus();
        });

        // Resign/abort
        $('#resign-btn').off('click').on('click', function() {
            if (!myGameId) return;
            gamesRef.child(myGameId).once('value').then(snap => {
                let d = snap.val();
                if (!d) return;
                let opponentUid = (d.white.uid === currentUser.uid) ? d.black.uid : d.white.uid;
                let result = {
                    type: 'resign',
                    by: currentUser.uid,
                    winner: opponentUid,
                    info: (currentUser.displayName || 'A player') + ' resigned'
                };
                gamesRef.child(myGameId).update({
                    status: 'ended',
                    result: result,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
                showResultModal(result);
                cleanupAfterGame();
            });
        });
        $('#abort-btn').off('click').on('click', function() {
            if (!myGameId) return;
            gamesRef.child(myGameId).once('value').then(snap => {
                let d = snap.val();
                if (!d) return;
                let opponentUid = (d.white.uid === currentUser.uid) ? d.black.uid : d.white.uid;
                let result = {
                    type: 'abort',
                    by: currentUser.uid,
                    winner: null,
                    info: (currentUser.displayName || 'A player') + ' aborted the game'
                };
                gamesRef.child(myGameId).update({
                    status: 'ended',
                    result: result,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
                showResultModal(result);
                cleanupAfterGame();
            });
        });
    }

    // Chessboard.js handlers, with click-to-move + drag/drop both supported
    function onDragStart(source, piece, position, orientation) {
        if (chess.game_over()) return false;
        if ((chess.turn() === 'w' && myColor !== 'w') || (chess.turn() === 'b' && myColor !== 'b')) {
            return false;
        }
        if ((myColor === 'w' && piece.search(/^w/) === -1) || (myColor === 'b' && piece.search(/^b/) === -1)) {
            return false;
        }
    }
    function onDrop(source, target) {
        removeAllHighlights();
        squareSelected = null; legalSquares = [];
        if (source === target) return; // no move
        let move = chess.move({
            from: source,
            to: target,
            promotion: 'q'
        });
        if (move === null) return 'snapback';
        updateMoveToDB(chess.fen());
    }
    function onSnapEnd() {
        board.position(chess.fen());
    }
    function updateMoveToDB(fen) {
        gamesRef.child(myGameId).once('value').then(snap => {
            let d = snap.val();
            if (!d || d.status === "ended") return;
            let now = Date.now();
            let prevTurn = d.turn;
            let nextTurn = (d.turn === 'w' ? 'b' : 'w');
            // calculate clock
            let c = d.clock || { w: timeSettings[d.mode], b: timeSettings[d.mode], running: true, last: now };
            let elapsed = Math.floor(((now - (c.last || now))/1000));
            if (elapsed < 0) elapsed = 0;
            if (prevTurn === 'w') c.w = Math.max(0, c.w - elapsed);
            else c.b = Math.max(0, c.b - elapsed);
            c.last = now;
            // Check timeout
            let result = null;
            if (c.w <= 0 || c.b <= 0) {
                c.running = false;
                c.winner = (c.w <= 0 ? d.black.uid : d.white.uid);
                result = {
                    type: 'timeout',
                    by: (c.w <= 0 ? d.white.uid : d.black.uid),
                    winner: (c.w <= 0 ? d.black.uid : d.white.uid),
                    info: (c.w <= 0 ? "White" : "Black") + " lost on time"
                };
            }
            let update = {
                fen: fen,
                turn: nextTurn,
                clock: c,
                lastUpdate: firebase.database.ServerValue.TIMESTAMP
            };
            if (result) {
                update.status = "ended";
                update.result = result;
            }
            gamesRef.child(myGameId).update(update);
            updateClockUI(c.w, c.b, nextTurn, c.winner);
        });
    }

    function updateStatus() {
        let status = "";
        if (chess.in_checkmate()) {
            status = "Checkmate! " + (chess.turn() === 'w' ? "Black" : "White") + " wins.";
        } else if (chess.in_draw()) {
            status = "Draw!";
        } else if (chess.in_stalemate()) {
            status = "Stalemate!";
        } else if (chess.in_check()) {
            status = "Check!";
        } else {
            status = (chess.turn() === myColor) ? "Your turn" : "Opponent's turn";
        }
        $('#gameStatus').text(status);
    }

    // ----- Chess Clock -----
    function updateClockUI(wtime, btime, turn, winner) {
        let wf = formatClock(wtime);
        let bf = formatClock(btime);
        $('#white-clock').text(wf).removeClass('active timeout');
        $('#black-clock').text(bf).removeClass('active timeout');
        if (winner) {
            if (winner === getUserByColor('w')) $('#black-clock').addClass('timeout');
            else if (winner === getUserByColor('b')) $('#white-clock').addClass('timeout');
        } else if (turn === 'w') $('#white-clock').addClass('active');
        else $('#black-clock').addClass('active');
    }
    function formatClock(secs) {
        if (secs <= 0) return "00:00";
        let m = Math.floor(secs / 60);
        let s = secs % 60;
        return (m < 10 ? "0" : "") + m + ":" + (s < 10 ? "0" : "") + s;
    }
    function getUserByColor(c) {
        if (!myGameId) return null;
        return (c === 'w'
            ? (board && board.orientation() === 'white' ? currentUser.uid : opponent && opponent.uid)
            : (board && board.orientation() === 'black' ? currentUser.uid : opponent && opponent.uid));
    }
    // Auto clock tick (local UI only, official clock from db)
    setInterval(function(){
        let w = $('#white-clock'), b = $('#black-clock');
        if (w.hasClass('active')) {
            let t = parseTime(w.text());
            if (t > 0) w.text(formatClock(t-1));
        } else if (b.hasClass('active')) {
            let t = parseTime(b.text());
            if (t > 0) b.text(formatClock(t-1));
        }
    }, 1000);
    function parseTime(str) {
        let [m,s] = str.split(':').map(Number);
        return m*60+s;
    }

    // Show a friendly modal when game ended by resign/abort/timeout/other
    function showResultModal(result) {
        let body = '';
        if (!result) body = 'Game ended.';
        else if (result.type === 'resign') {
            if (result.by === currentUser.uid) body = 'You resigned. You lost the game.';
            else body = 'Your opponent resigned. You win!';
        } else if (result.type === 'abort') {
            if (result.by === currentUser.uid) body = 'You aborted the game.';
            else body = 'Your opponent aborted the game.';
        } else if (result.type === 'timeout') {
            if (result.by === currentUser.uid) body = 'You lost on time.';
            else body = 'Opponent lost on time. You win by timeout!';
        } else if (result.type === 'game_over') {
            body = result.info || 'Game finished.';
        } else body = result.info || 'Game ended.';
        $('#resultModalBody').text(body);
        $('#resultModal').modal({backdrop: 'static', keyboard: false});
    }
    function cleanupAfterGame() {
        myGameId = null; myColor = null; chess = null;
        if (board) { board.destroy(); board = null; }
        setTimeout(function(){ showScreen('home-screen'); }, 300);
    }

    // If user closes window while in a game, attempt to mark as abort (best-effort)
    window.addEventListener('beforeunload', function(e) {
        if (myGameId && currentUser) {
            try {
                let result = {
                    type: 'abort',
                    by: currentUser.uid,
                    winner: null,
                    info: (currentUser.displayName || 'A player') + ' disconnected'
                };
                gamesRef.child(myGameId).update({
                    status: 'ended',
                    result: result,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
            } catch (err) {}
            waitingRef.transaction(waiting => {
                if (!waiting) return [];
                return waiting.filter(item => typeof item === "object" ? item.uid !== (currentUser && currentUser.uid) : item !== (currentUser && currentUser.uid));
            });
        } else {
            waitingRef.transaction(waiting => {
                if (!waiting) return [];
                return waiting.filter(item => typeof item === "object" ? item.uid !== (currentUser && currentUser.uid) : item !== (currentUser && currentUser.uid));
            });
        }
    });
    auth.onAuthStateChanged(user => {
        if (!user && myGameId) {
            try {
                let result = {
                    type: 'abort',
                    by: currentUser ? currentUser.uid : null,
                    winner: null,
                    info: 'Player signed out'
                };
                gamesRef.child(myGameId).update({
                    status: 'ended',
                    result: result,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });
            } catch (err) {}
            cleanupAfterGame();
        }
    });
    </script>
</body>
		</html>
