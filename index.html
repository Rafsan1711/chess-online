<!doctype html>
<html lang="bn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Online Chess — Launch Ready (v2)</title>

  <!-- Bootstrap for basic UI -->
  <link rel="stylesheet"
        href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        crossorigin="anonymous">

  <!-- Chessboard.js CSS -->
  <link rel="stylesheet"
        href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
        crossorigin="anonymous">

  <style>
    body { background:#0f172a; color:#e6eef8; font-family: Arial, Helvetica, sans-serif; }
    main { padding: 20px; max-width: 1100px; margin: 0 auto; }
    .screen { display: none; }
    .visible { display: block; }
    #myBoard { width: 480px; margin: 0 auto; }
    .controls { text-align:center; margin-top:12px; }
    .info { text-align:center; margin-top:8px; color:#9fb0d5; }
    footer { text-align:center; color:#6b7d99; margin-top: 18px; }
    .btn-outline-safe { border-color:#60a5fa; color:#60a5fa }
    .highlight-white { box-shadow: inset 0 0 40px rgba(255,255,255,0.06); }
    .highlight-black { box-shadow: inset 0 0 40px rgba(0,0,0,0.35); }
    /* small responsive */
    @media (max-width:540px){
       #myBoard { width: 95vw; }
    }
  </style>
</head>

<body>
  <main>
    <!-- LOGIN SCREEN -->
    <section id="loginScreen" class="screen visible">
      <h1 class="text-center">Online Chess (v2)</h1>
      <p class="text-center info">Sign in with Google to play real-time with others (Firebase Auth + Realtime DB).</p>
      <div class="text-center my-4">
        <button id="btnGoogleSignIn" class="btn btn-primary btn-lg">Sign in with Google</button>
      </div>
    </section>

    <!-- HOME SCREEN -->
    <section id="homeScreen" class="screen px-3">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <h3 id="welcomeText">Welcome</h3>
          <div id="userInfo" class="text-muted"></div>
        </div>
        <div>
          <button id="btnSignOut" class="btn btn-outline-light">Sign out</button>
        </div>
      </div>

      <hr/>

      <div class="text-center my-4">
        <button id="btnStartGame" class="btn btn-success btn-lg">Start Game (Quick Match)</button>
      </div>

      <div class="info">Click Start Game → you'll be placed into waiting queue. When two players are matched, the match starts instantly for both players.</div>
    </section>

    <!-- WAITING SCREEN -->
    <section id="waitingScreen" class="screen text-center px-3">
      <h3>Waiting for an opponent...</h3>
      <p id="waitingInfo" class="info">You are in queue.</p>
      <div class="my-3">
        <button id="btnCancelWaiting" class="btn btn-danger">Cancel</button>
      </div>
    </section>

    <!-- MATCH SCREEN -->
    <section id="matchScreen" class="screen px-3">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <h4 id="matchVs">Match</h4>
          <p id="matchStatus" class="text-muted"></p>
        </div>
        <div>
          <button id="btnLeaveMatch" class="btn btn-outline-danger">Leave Match</button>
        </div>
      </div>

      <div id="myBoard" class="mx-auto mt-3"></div>

      <div class="info mt-2">
        Turn: <span id="turnIndicator">-</span> &nbsp; | &nbsp; FEN: <span id="fenDisplay">-</span>
      </div>

      <div class="controls">
        <button id="btnResign" class="btn btn-warning">Resign</button>
      </div>
    </section>
  </main>

  <footer>
    Put chess.js in js/chess.js, piece images in /piece (wK.svg, bK.svg, etc).
  </footer>

  <!-- jQuery (used by chessboard.js) -->
  <script src="https://code.jquery.com/jquery-3.5.1.js" crossorigin="anonymous"></script>

  <!-- Firebase (compat libraries for simpler migration) -->
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

  <!-- Chessboard.js -->
  <script defer src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
          crossorigin="anonymous"></script>

  <!-- chess.js (you said you'll keep locally at js/chess.js) -->
  <script defer src="js/chess.js"></script>

  <script>
    // ============================
    // IMPORTANT: Replace with YOUR Firebase config (launch-ready: fill these)
    // ============================
    const firebaseConfig = {
      apiKey: "REPLACE_WITH_YOUR_API_KEY",
      authDomain: "REPLACE_WITH_PROJECT.firebaseapp.com",
      databaseURL: "https://REPLACE_WITH_PROJECT.firebaseio.com",
      projectId: "REPLACE_WITH_PROJECT",
      storageBucket: "REPLACE_WITH_PROJECT.appspot.com",
      messagingSenderId: "REPLACE_ME",
      appId: "REPLACE_ME"
    };
    // ============================
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    // UI refs
    const loginScreen = document.getElementById('loginScreen');
    const homeScreen = document.getElementById('homeScreen');
    const waitingScreen = document.getElementById('waitingScreen');
    const matchScreen = document.getElementById('matchScreen');

    const btnGoogleSignIn = document.getElementById('btnGoogleSignIn');
    const btnSignOut = document.getElementById('btnSignOut');
    const welcomeText = document.getElementById('welcomeText');
    const userInfo = document.getElementById('userInfo');
    const btnStartGame = document.getElementById('btnStartGame');
    const btnCancelWaiting = document.getElementById('btnCancelWaiting');
    const waitingInfo = document.getElementById('waitingInfo');

    const matchVs = document.getElementById('matchVs');
    const matchStatus = document.getElementById('matchStatus');
    const turnIndicator = document.getElementById('turnIndicator');
    const fenDisplay = document.getElementById('fenDisplay');
    const btnLeaveMatch = document.getElementById('btnLeaveMatch');
    const btnResign = document.getElementById('btnResign');

    // state
    let currentUser = null;
    let waitingRef = null;
    let waitingKey = null;
    let pairListener = null;
    let waitingListener = null;

    let matchId = null;
    let matchRef = null;
    let matchMovesRef = null;
    let matchListener = null;
    let matchMovesChildListener = null;

    // chess state
    let board = null;
    let game = null;
    let myColor = null; // 'w' or 'b'

    // helper: show screen
    function showScreen(screenEl) {
      [loginScreen, homeScreen, waitingScreen, matchScreen].forEach(s => s.classList.remove('visible'));
      screenEl.classList.add('visible');
    }

    // Auth listeners
    btnGoogleSignIn.addEventListener('click', () => {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).catch(err => alert('Sign-in error: ' + err.message));
    });

    btnSignOut.addEventListener('click', async () => {
      await cancelWaiting();
      await leaveMatchCleanup();
      auth.signOut();
    });

    auth.onAuthStateChanged(user => {
      currentUser = user;
      if (user) {
        welcomeText.textContent = `Welcome, ${user.displayName || 'Player'}`;
        userInfo.textContent = `UID: ${user.uid}`;
        // presence
        const presRef = db.ref('users/' + user.uid + '/presence');
        presRef.set(true);
        presRef.onDisconnect().remove();

        // Listen for currentMatch path as secondary method (optional)
        db.ref('users/' + user.uid + '/currentMatch').on('value', snap => {
          const mid = snap.val();
          if (mid) {
            // someone assigned match via user node
            enterMatch(mid);
          }
        });

        showScreen(homeScreen);
      } else {
        showScreen(loginScreen);
      }
    });

    // Start & Waiting logic (improved)
    btnStartGame.addEventListener('click', async () => {
      if (!currentUser) return alert('Please sign in.');
      // push waiting entry
      waitingRef = db.ref('waiting').push();
      waitingKey = waitingRef.key;
      await waitingRef.set({
        uid: currentUser.uid,
        name: currentUser.displayName || '',
        ts: firebase.database.ServerValue.TIMESTAMP,
        matchId: null
      });
      // ensure removal on disconnect
      waitingRef.onDisconnect().remove();

      // Listen to own waiting entry — this guarantees you'll detect when someone assigns matchId
      if (waitingListener) waitingRef.off('value', waitingListener);
      waitingListener = waitingRef.on('value', snap => {
        const val = snap.val();
        if (!val) return; // probably removed
        if (val.matchId) {
          // matched — enter match
          enterMatch(val.matchId);
        }
      });

      showScreen(waitingScreen);
      waitingInfo.textContent = 'You are waiting...';

      // start watching waiting list to attempt pairing (only one listener)
      if (!pairListener) {
        pairListener = db.ref('waiting');
        pairListener.on('value', snap => {
          const waiting = snap.val() || {};
          const keys = Object.keys(waiting);
          // only try if there are at least 2 entries
          if (keys.length >= 2) {
            tryPairing();
          }
        });
      }
    });

    btnCancelWaiting.addEventListener('click', () => {
      cancelWaiting();
    });

    async function cancelWaiting() {
      if (waitingRef) {
        try { await waitingRef.remove(); } catch (e) {}
        if (waitingListener) { waitingRef.off('value', waitingListener); waitingListener = null; }
        waitingRef = null;
        waitingKey = null;
      }
      if (pairListener) {
        pairListener.off();
        pairListener = null;
      }
      showScreen(homeScreen);
    }

    // Pairing logic with lock + notifying both waiting entries explicitly
    async function tryPairing() {
      if (!currentUser) return;

      const lockRef = db.ref('pairingLock');
      lockRef.transaction(current => {
        if (current === null) {
          return currentUser.uid; // acquire lock
        }
        return; // already held
      }, async (err, committed, snap) => {
        if (err) return;
        if (!committed) return; // couldn't acquire
        // acquired lock
        try {
          // read ordered by timestamp to get oldest two
          const waitingSnap = await db.ref('waiting').orderByChild('ts').once('value');
          const waitingObj = waitingSnap.val() || {};
          const entries = [];
          waitingSnap.forEach(child => {
            entries.push({ key: child.key, val: child.val() });
          });
          if (entries.length < 2) {
            await db.ref('pairingLock').remove();
            return;
          }
          // pick oldest two
          const a = entries[0];
          const b = entries[1];
          // Create match
          const newMatchRef = db.ref('matches').push();
          const newMatchId = newMatchRef.key;

          // default starting FEN and metadata
          const startingChess = (typeof Chess !== 'undefined') ? new Chess() : null;
          const startingFen = startingChess ? startingChess.fen() : 'start';

          const players = {};
          // assign colors deterministically: a => white, b => black
          players['white'] = { uid: a.val.uid, name: a.val.name || '' };
          players['black'] = { uid: b.val.uid, name: b.val.name || '' };

          await newMatchRef.set({
            fen: startingFen,
            turn: 'w',
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            players: players,
            moves: {}
          });

          // Notify both waiting entries by setting matchId on each waiting node.
          const updates = {};
          updates['waiting/' + a.key + '/matchId'] = newMatchId;
          updates['waiting/' + b.key + '/matchId'] = newMatchId;

          // Also set users/{uid}/currentMatch as redundancy
          updates['users/' + a.val.uid + '/currentMatch'] = newMatchId;
          updates['users/' + b.val.uid + '/currentMatch'] = newMatchId;

          await db.ref().update(updates);
          // release lock
          await db.ref('pairingLock').remove();
        } catch (e) {
          // release lock in any case
          await db.ref('pairingLock').remove();
        }
      });
    }

    // ENTER MATCH (listens to match records + moves)
    async function enterMatch(id) {
      // cleanup any previous listeners
      await leaveMatchCleanup();

      matchId = id;
      matchRef = db.ref('matches/' + matchId);
      matchMovesRef = db.ref('matches/' + matchId + '/moves');

      // fetch match once
      const snap = await matchRef.once('value');
      const match = snap.val();
      if (!match) {
        alert('Match no longer exists.');
        showScreen(homeScreen);
        return;
      }

      // determine my color
      if (match.players && match.players.white && match.players.white.uid === currentUser.uid) {
        myColor = 'w';
      } else if (match.players && match.players.black && match.players.black.uid === currentUser.uid) {
        myColor = 'b';
      } else {
        myColor = 'spectator';
      }

      matchVs.textContent = `${match.players.white.name || 'White'} vs ${match.players.black.name || 'Black'}`;
      matchStatus.textContent = `You are ${myColor === 'w' ? 'White' : myColor === 'b' ? 'Black' : 'Spectator'}`;

      // init chess.js game
      if (!game) game = new Chess();
      if (match.fen && game.validate_fen) {
        // chess.js exposes validate_fen; try load
        try { game.load(match.fen); } catch (e) { game.reset(); }
      } else {
        game.reset();
      }

      // initialize chessboard.js with custom pieceTheme to use your /piece folder
      if (!board) {
        board = Chessboard('myBoard', {
          draggable: true,
          position: game.fen(),
          onDragStart: onDragStart,
          onDrop: onDrop,
          onSnapEnd: onSnapEnd,
          // pieceTheme: function(piece) { return 'piece/' + piece + '.svg'; } // alternative signature supported
          pieceTheme: function(piece) {
            // chessboard.js passes piece like 'wK','bQ' etc.
            return 'piece/' + piece + '.svg';
          }
        });
      } else {
        board.position(game.fen());
      }

      // Listen for match metadata updates (fen/turn)
      matchListener = matchRef.on('value', snap => {
        const data = snap.val();
        if (!data) return;
        fenDisplay.textContent = data.fen || '';
        turnIndicator.textContent = data.turn === 'w' ? 'White' : 'Black';
      });

      // listen for moves appended
      matchMovesChildListener = matchMovesRef.on('child_added', snap => {
        const mv = snap.val();
        if (!mv) return;
        // don't re-apply moves authored by ourselves twice:
        if (mv.authorUid === currentUser.uid) return;
        applyRemoteMove(mv);
      });

      showScreen(matchScreen);
    }

    // Chessboard callbacks
    function onDragStart(source, piece, position, orientation) {
      if (!game) return false;
      if (game.game_over()) return false;
      // ensure it's player's turn
      if (game.turn() === 'w' && piece.search(/^b/) !== -1) return false;
      if (game.turn() === 'b' && piece.search(/^w/) !== -1) return false;
      if (myColor !== game.turn()) return false; // spectator or wrong side can't move
      return true;
    }

    function onDrop(source, target) {
      // attempt move
      const move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) return 'snapback';

      // update board
      board.position(game.fen());

      // push move to DB
      const mv = {
        from: move.from,
        to: move.to,
        piece: move.piece,
        san: move.san,
        flags: move.flags,
        color: move.color,
        promotion: move.promotion || null,
        authorUid: currentUser.uid,
        ts: firebase.database.ServerValue.TIMESTAMP
      };
      matchMovesRef.push(mv).catch(e => console.warn('push move failed', e));

      // update match fen & turn
      matchRef.update({ fen: game.fen(), turn: game.turn() }).catch(e => console.warn('update match failed', e));
    }

    function onSnapEnd() {
      board.position(game.fen());
    }

    // Apply remote move safely
    function applyRemoteMove(moveObj) {
      if (!game) return;
      // apply move by from/to/promotion
      const m = game.move({ from: moveObj.from, to: moveObj.to, promotion: moveObj.promotion || 'q' });
      if (m) {
        board.position(game.fen());
        matchRef.update({ fen: game.fen(), turn: game.turn() }).catch(()=>{});
      }
    }

    // Leave match + cleanup listeners
    async function leaveMatchCleanup() {
      try {
        if (matchListener && matchRef) { matchRef.off('value', matchListener); matchListener = null; }
        if (matchMovesChildListener && matchMovesRef) { matchMovesRef.off('child_added', matchMovesChildListener); matchMovesChildListener = null; }
        if (matchRef && currentUser) {
          // remove users/{uid}/currentMatch if it's pointing to this match
          const userMatchRef = db.ref('users/' + currentUser.uid + '/currentMatch');
          const snap = await userMatchRef.once('value');
          if (snap.val() === matchId) {
            userMatchRef.remove().catch(()=>{});
          }
        }
      } catch (e) {}
      matchId = null;
      matchRef = null;
      matchMovesRef = null;
      // don't remove board/game; keep them for new match
      showScreen(homeScreen);
    }

    btnLeaveMatch.addEventListener('click', async () => {
      await leaveMatchCleanup();
      // Also remove waiting entry if any
      await cancelWaiting();
    });

    // When page unload remove waiting and presence
    window.addEventListener('beforeunload', async () => {
      if (waitingRef) try { await waitingRef.remove(); } catch (e) {}
      if (currentUser) {
        try { await db.ref('users/' + currentUser.uid + '/presence').remove(); } catch (e) {}
        try { await db.ref('users/' + currentUser.uid + '/currentMatch').remove(); } catch (e) {}
      }
    });

    // Resign button (simple implementation: write a result node and remove match)
    btnResign.addEventListener('click', async () => {
      if (!matchId || !currentUser) return;
      const result = {
        resignedBy: currentUser.uid,
        ts: firebase.database.ServerValue.TIMESTAMP
      };
      await db.ref('matches/' + matchId + '/result').set(result);
      // optional: remove match after short delay
      setTimeout(()=> db.ref('matches/' + matchId).remove().catch(()=>{}), 2000);
      await leaveMatchCleanup();
    });

    // Ensure board variable exists if loaded before chess.js:
    (function ensureChessLoaded(){
      // If chess.js hasn't loaded yet, wait
      function initIfReady(){
        if (typeof Chess !== 'undefined') {
          if (!game) game = new Chess();
          // nothing else required; board instantiation happens when match starts
        } else {
          setTimeout(initIfReady, 150);
        }
      }
      initIfReady();
    })();

  </script>
</body>
	</html>
