<!DOCTYPE html>
<html lang="en" class="bg-gray-900 text-white">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Online Chess Multiplayer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .board-grid {
      margin: 0 auto;
      display: grid;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 0 8px #222;
      gap: 0px;
      max-width: 98vw;
    }
    .chess-square {
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
      user-select: none;
      border: 1px solid #333;
      box-sizing: border-box;
      transition: background 0.2s, outline 0.2s;
      position: relative;
    }
    .chess-square.light { background: #f0d9b5; }
    .chess-square.dark { background: #b58863; }
    .chess-square.selected { outline: 3px solid yellow; z-index: 10;}
    .chess-square.check { box-shadow: 0 0 12px 4px #f00 inset !important;}
    .chess-square.highlight { background: rgba(255,255,0,0.4); }
    .chess-square.legal-move::after {
      content: "âšª";
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.3rem;
      pointer-events: none;
      color: #fff;
      filter: drop-shadow(0 0 2px #222);
    }
    .piece { width: 90%; height: 90%; user-select: none; }
    #status { font-size: 1.3rem; font-weight: bold; margin: 1rem 0; text-align: center; padding: 0.7rem 1.4rem; border-radius: 8px; }
    .white-turn { background: #4a90e2; box-shadow: 0 0 12px #4a90e2;}
    .black-turn { background: #e94e77; box-shadow: 0 0 12px #e94e77;}
    #winner-message { font-size: 1.9rem; font-weight: 800; text-align: center; margin: 1.5rem 0; color: #00ff00; text-shadow: 0 0 6px #00ff00;}
    #restart { display: none; margin: 0 auto 2rem auto; padding: 12px 30px; font-size: 1.2rem; font-weight: 700; background: #555; border: none; border-radius: 10px; color: white; cursor: pointer;}
    #restart:hover { background: #777;}
    #modal { position: fixed; inset: 0; background: rgba(0,0,0,0.75); display: none; align-items: center; justify-content: center; z-index: 1000; }
    #modal.active { display: flex; }
    #modal-content { background: #111; padding: 2rem; border-radius: 10px; max-width: 400px; width: 90%; color: white; text-align: center; }
    .loader { border: 5px solid #444; border-top: 5px solid #00ff00; border-radius: 50%; width: 50px; height: 50px; animation: spin 1.5s linear infinite; margin: 0 auto 1rem auto; }
    @keyframes spin { 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);} }
    @media (max-width: 600px) {
      .board-grid { max-width: 95vw; }
      .chess-square { font-size: 1.1rem !important; }
    }
    .promotion-modal-bg {
      position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; z-index: 2000;
    }
    .promotion-modal-bg.active { display: flex; }
    .promotion-modal {
      background: #222; border-radius: 14px; padding: 2rem; text-align: center; color: #fff; box-shadow: 0 0 22px #000;
    }
    .promotion-piece { cursor: pointer; margin: 0 10px; font-size: 2.5rem; transition: transform 0.1s; }
    .promotion-piece:hover { transform: scale(1.2);}
    .pinned { outline: 2px dashed #00eaff !important; }
    .forked { box-shadow: 0 0 8px #ffa700 !important;}
  </style>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
</head>
<body class="min-h-screen flex flex-col">

  <div id="auth-screen" class="flex-grow flex flex-col items-center justify-center p-4">
    <h1 class="text-5xl font-extrabold mb-8">Online Chess Multiplayer</h1>
    <button id="signin-btn" class="bg-blue-600 hover:bg-blue-700 px-8 py-3 rounded-lg font-semibold shadow" onclick="signIn()">Sign in with Google</button>
  </div>

  <div id="app" class="hidden flex-grow flex flex-col">
    <header class="flex justify-between items-center p-4 border-b border-gray-700 relative">
      <div><span id="username" class="font-bold text-xl"></span> | Rating: <span id="rating" class="font-semibold">0</span></div>
    </header>
    <main class="flex-grow overflow-auto p-4">
      <section id="screen-home" class="space-y-6">
        <div class="flex justify-center space-x-4 mb-6">
          <button id="mode-2" class="mode-btn px-5 py-2 border border-white rounded active" onclick="selectMode(2)">2 Players</button>
        </div>
        <div class="flex justify-center mb-6">
          <button id="start-btn" class="bg-green-600 hover:bg-green-700 px-8 py-3 rounded-lg font-semibold" onclick="startMatch()">Start Online Game</button>
        </div>
        <div id="match-link" class="text-center mb-6 text-sm text-blue-400 break-all"></div>
        <div id="status" class="white-turn text-white"></div>
        <div id="game-board" class="mx-auto mt-2 mb-2" style="user-select:none;"></div>
        <button id="restart" onclick="restartGame()">Restart Game</button>
        <div id="winner-message"></div>
      </section>
    </main>
  </div>

  <div id="modal">
    <div id="modal-content">
      <h2 class="text-2xl mb-4">Waiting for other player...</h2>
      <div class="loader"></div>
      <p id="players-found" class="mb-4 font-semibold text-lg">Players found: 1/2</p>
    </div>
  </div>

  <div id="promotion-modal" class="promotion-modal-bg">
    <div class="promotion-modal">
      <h3 class="mb-4 text-lg font-bold">Pawn Promotion:</h3>
      <div id="promotion-options"></div>
    </div>
  </div>

  <script>
    // ==== FIREBASE CONFIGURATION ====
    const firebaseConfig = {
      apiKey: "AIzaSyB-5CakD79CthsI-_vcqblOCN1sXS6U8u8",
      authDomain: "dot-and-box-90d27.firebaseapp.com",
      databaseURL: "https://dot-and-box-90d27-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "dot-and-box-90d27",
      storageBucket: "dot-and-box-90d27.appspot.com",
      messagingSenderId: "913945926983",
      appId: "1:913945926983:web:b4c00c2cffff5b6fa7c062"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    // UI Elements
    const authScreen = document.getElementById('auth-screen');
    const app = document.getElementById('app');
    const usernameEl = document.getElementById('username');
    const ratingEl = document.getElementById('rating');
    const startBtn = document.getElementById('start-btn');
    const matchLinkEl = document.getElementById('match-link');
    const statusEl = document.getElementById('status');
    const gameBoard = document.getElementById('game-board');
    const restartBtn = document.getElementById('restart');
    const winnerMessage = document.getElementById('winner-message');
    const modal = document.getElementById('modal');
    const playersFoundEl = document.getElementById('players-found');
    const promotionModal = document.getElementById('promotion-modal');
    const promotionOptions = document.getElementById('promotion-options');

    // GLOBALS
    let currentUser = null;
    let userData = null;
    let matchId = null;
    let isMyTurn = false;
    let players = [];
    let playersInfo = {};
    let finished = false;
    let playerIndex = null;
    let matchCleanupScheduled = false;
    let promotionCallback = null;

    // ==== AUTH & USER ====
    auth.onAuthStateChanged(async user => {
      if (user) {
        currentUser = user;
        await loadUserData();
        authScreen.style.display = 'none';
        app.classList.remove('hidden');
        showScreen('home');
        setupInitialUI();
      } else {
        currentUser = null;
        userData = null;
        app.classList.add('hidden');
        authScreen.style.display = 'flex';
      }
    });

    async function loadUserData() {
      if (!currentUser) return;
      const snapshot = await db.ref('users/' + currentUser.uid).get();
      if (snapshot.exists()) {
        userData = snapshot.val();
      } else {
        userData = {
          username: currentUser.displayName || 'Anonymous',
          rating: 1000,
        };
        await db.ref('users/' + currentUser.uid).set(userData);
      }
      usernameEl.textContent = userData.username;
      ratingEl.textContent = userData.rating || 0;
    }

    function signIn() {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider);
    }

    function showScreen(name) {}

    function setupInitialUI() {
      restartBtn.style.display = 'none';
      winnerMessage.textContent = '';
      statusEl.textContent = '';
      matchLinkEl.textContent = '';
      finished = false;
    }

    function selectMode(n) {}

    function startMatch() {
      if (!currentUser) return alert('Please sign in first.');
      startBtn.disabled = true;
      createOrJoinMatch();
    }

    async function createOrJoinMatch() {
      modal.classList.add('active');
      playersFoundEl.textContent = `Players found: 1/2`;
      let openMatchId = null;
      const matchesSnapshot = await db.ref('matches').orderByChild('mode').equalTo(2).get();
      if (matchesSnapshot.exists()) {
        matchesSnapshot.forEach(matchSnap => {
          const m = matchSnap.val();
          if (!m.started && Object.keys(m.players || {}).length < 2) {
            openMatchId = matchSnap.key;
            return true;
          }
        });
      }
      if (openMatchId) {
        matchId = openMatchId;
        await joinMatch(matchId);
      } else {
        const newMatchRef = db.ref('matches').push();
        matchId = newMatchRef.key;
        const playersObj = {};
        playersObj[currentUser.uid] = {
          username: userData.username,
          rating: userData.rating || 0,
        };
        await newMatchRef.set({
          mode: 2,
          started: false,
          players: playersObj,
          chess: getInitialChessState(),
          turnIndex: 0,
        });
        await waitForPlayers(matchId);
      }
    }

    async function joinMatch(id) {
      const matchRef = db.ref('matches/' + id);
      const matchSnap = await matchRef.get();
      if (!matchSnap.exists()) {
        alert('Match not found');
        modal.classList.remove('active');
        startBtn.disabled = false;
        return;
      }
      const match = matchSnap.val();
      if (match.started) {
        alert('Match already started');
        modal.classList.remove('active');
        startBtn.disabled = false;
        return;
      }
      if (match.players && Object.keys(match.players).includes(currentUser.uid)) {
        listenToMatch(matchId);
        return;
      }
      await matchRef.child('players/' + currentUser.uid).set({
        username: userData.username,
        rating: userData.rating || 0,
      });
      await waitForPlayers(id);
    }

    async function waitForPlayers(id) {
      const matchRef = db.ref('matches/' + id);
      matchRef.on('value', snapshot => {
        if (!snapshot.exists()) return;
        const data = snapshot.val();
        players = Object.keys(data.players || {});
        playersInfo = data.players || {};
        playersFoundEl.textContent = `Players found: ${players.length}/2`;
        if (players.length === 2 && !data.started) {
          matchRef.update({ started: true });
        }
        if (data.started) {
          modal.classList.remove('active');
          listenToMatch(id);
        }
      });
    }

    function listenToMatch(id) {
      matchId = id;
      const matchRef = db.ref('matches/' + id);
      finished = false;
      matchRef.on('value', async snapshot => {
        if (!snapshot.exists()) return;
        const gameData = snapshot.val();
        players = Object.keys(gameData.players || {});
        playersInfo = gameData.players || {};
        playerIndex = players.indexOf(currentUser.uid);
        isMyTurn = (gameData.turnIndex === playerIndex);
        updateTurnStatus(gameData);
        renderGameBoard(gameData.chess);
        if (gameData.chess.status === "finished" && !finished) {
          finished = true;
          setTimeout(() => {
            winnerMessage.textContent = gameData.chess.winner === players[playerIndex] ? 'You win!' : `${playersInfo[gameData.chess.winner].username} wins!`;
            restartBtn.style.display = 'block';
            statusEl.textContent = '';
            matchRef.off('value');
            scheduleMatchCleanup();
          }, 500);
        }
      });
    }

    function scheduleMatchCleanup() {
      if (!matchId || matchCleanupScheduled) return;
      matchCleanupScheduled = true;
      setTimeout(() => {
        db.ref('matches/' + matchId).remove();
        matchId = null;
        matchCleanupScheduled = false;
      }, 1200);
    }

    function updateTurnStatus(gameData) {
      if (!gameData) return;
      const currentTurnIndex = gameData.turnIndex || 0;
      isMyTurn = (playerIndex === currentTurnIndex);
      const turnPlayer = players[currentTurnIndex];
      const turnName = playersInfo[turnPlayer]?.username || 'Unknown';
      statusEl.textContent = isMyTurn ? `Your turn (${turnName})` : `Waiting for ${turnName}`;
      statusEl.className = currentTurnIndex === 0 ? 'white-turn' : 'black-turn';
    }

    function getInitialChessState() {
      return {
        board: [
          ["bR","bN","bB","bQ","bK","bB","bN","bR"],
          ["bP","bP","bP","bP","bP","bP","bP","bP"],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["wP","wP","wP","wP","wP","wP","wP","wP"],
          ["wR","wN","wB","wQ","wK","wB","wN","wR"]
        ],
        turn: "white",
        selected: null,
        highlights: [],
        status: "active",
        winner: null,
        lastMove: null,
        check: false,
        checkmate: false,
        pinned: [],
        forked: [],
        promotion: null
      };
    }

    function renderGameBoard(chess) {
      if (!chess) return;
      const board = chess.board;
      let boardHTML = `<div class="board-grid" style="
        grid-template-columns: repeat(8, 48px);
        grid-template-rows: repeat(8, 48px);
        width: ${48*8}px;
      ">`;
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const light = (r + c) % 2 === 0 ? 'light' : 'dark';
          let extra = '';
          if (chess.selected && chess.selected.row === r && chess.selected.col === c) extra += ' selected';
          if (chess.highlights && chess.highlights.some(mv => mv.row === r && mv.col === c)) extra += ' highlight legal-move';
          // Show check
          if (chess.check && board[r][c] && board[r][c][1] === "K" && board[r][c][0] === (chess.turn === "white" ? "b" : "w")) extra += ' check';
          // Show pinned/fork
          if (chess.pinned && chess.pinned.some(p => p.row === r && p.col === c)) extra += ' pinned';
          if (chess.forked && chess.forked.some(p => p.row === r && p.col === c)) extra += ' forked';
          boardHTML += `<div class="chess-square ${light}${extra}" data-row="${r}" data-col="${c}"></div>`;
        }
      }
      boardHTML += '</div>';
      gameBoard.innerHTML = boardHTML;
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const code = board[r][c];
          if (code) {
            const img = document.createElement("img");
            img.className = "piece";
            img.src = getPieceSVG(code);
            img.draggable = false;
            const squareDiv = document.querySelector(`.chess-square[data-row="${r}"][data-col="${c}"]`);
            squareDiv.appendChild(img);
          }
        }
      }
      document.querySelectorAll('.chess-square').forEach(sq => {
        sq.onclick = () => handleSquareClick(+sq.dataset.row, +sq.dataset.col);
        if (isMyTurn && !finished) {
          sq.style.cursor = 'pointer';
        } else {
          sq.style.cursor = 'not-allowed';
        }
      });
      // Promotion modal
      if (chess.promotion && chess.promotion.active && isMyTurn) {
        showPromotionModal(chess.promotion, (piece) => {
          db.ref('matches/' + matchId + '/chess/promotion').set({ ...chess.promotion, chosen: piece });
        });
      } else {
        hidePromotionModal();
      }
    }

    function getPieceSVG(code) {
      return `https://upload.wikimedia.org/wikipedia/commons/${{
        wK: "4/42/Chess_klt45.svg",
        wQ: "1/15/Chess_qlt45.svg",
        wR: "7/72/Chess_rlt45.svg",
        wB: "b/b1/Chess_blt45.svg",
        wN: "7/70/Chess_nlt45.svg",
        wP: "4/45/Chess_plt45.svg",
        bK: "f/f1/Chess_kdt45.svg",
        bQ: "4/47/Chess_qdt45.svg",
        bR: "f/ff/Chess_rdt45.svg",
        bB: "9/98/Chess_bdt45.svg",
        bN: "e/ef/Chess_ndt45.svg",
        bP: "c/c7/Chess_pdt45.svg"
      }[code]}`;
    }

    // --- Chess Logic ---
    function handleSquareClick(row, col) {
      if (!isMyTurn || finished) return;
      db.ref('matches/' + matchId).transaction(match => {
        if (!match || match.chess.status !== "active") return;
        const chess = match.chess;
        const side = chess.turn;
        const mySide = playerIndex === 0 ? "white" : "black";
        if (side !== mySide) return; // Only allow my move

        // If promotion modal waiting, do nothing
        if (chess.promotion && chess.promotion.active && !chess.promotion.chosen) return;

        // Handle pawn promotion choice
        if (chess.promotion && chess.promotion.active && chess.promotion.chosen) {
          // Apply promotion
          const { row: prow, col: pcol, color, chosen } = chess.promotion;
          chess.board[prow][pcol] = color + chosen;
          chess.promotion = null;
          chess.turn = side === "white" ? "black" : "white";
          match.turnIndex = (match.turnIndex + 1) % 2;
          chess.selected = null;
          chess.highlights = [];
          // Check/checkmate after promotion
          applyCheckStates(chess);
          match.chess = chess;
          return match;
        }

        // --- Select piece ---
        const code = chess.board[row][col];
        if (!chess.selected) {
          if ((side === "white" && code && code.startsWith('w') && playerIndex === 0) ||
              (side === "black" && code && code.startsWith('b') && playerIndex === 1)) {
            chess.selected = { row, col };
            chess.highlights = getLegalMovesFull(chess.board, row, col, side, chess, true);
          }
        } else {
          // Try to move
          const legal = chess.highlights.find(mv => mv.row === row && mv.col === col);
          if (legal) {
            // Move logic with full legality
            const from = chess.selected;
            const to = { row, col };
            let moving = chess.board[from.row][from.col];
            let target = chess.board[to.row][to.col];

            // Castling logic
            if (moving[1] === "K" && Math.abs(to.col - from.col) === 2) {
              // King moves 2 squares = castling
              if (to.col === 6) { // King-side
                chess.board[from.row][7] = ""; // Remove rook
                chess.board[from.row][5] = moving[0] + "R";
              } else if (to.col === 2) { // Queen-side
                chess.board[from.row][0] = "";
                chess.board[from.row][3] = moving[0] + "R";
              }
            }

            // Pawn promotion
            if (moving[1] === "P" &&
                ((moving[0] === "w" && to.row === 0) || (moving[0] === "b" && to.row === 7))) {
              // Set promotion modal
              chess.board[from.row][from.col] = "";
              chess.board[to.row][to.col] = "";
              chess.promotion = {
                active: true,
                row: to.row,
                col: to.col,
                color: moving[0]
              };
              chess.selected = null;
              chess.highlights = [];
              match.chess = chess;
              return match;
            }

            // En passant
            if (moving[1] === "P" && target === "" && from.col !== to.col) {
              // Capturing empty square = en passant
              const epRow = from.row + (moving[0] === "w" ? -1 : 1);
              chess.board[epRow][to.col] = "";
            }

            // Move piece
            chess.board[from.row][from.col] = "";
            chess.board[to.row][to.col] = moving;
            chess.lastMove = {from, to, moving, target};

            // Next turn
            chess.turn = side === "white" ? "black" : "white";
            match.turnIndex = (match.turnIndex + 1) % 2;
            chess.selected = null;
            chess.highlights = [];

            // Check/checkmate/fork/pin
            applyCheckStates(chess);

            // Game end
            if (chess.checkmate) {
              chess.status = "finished";
              chess.winner = side;
            }
          } else {
            // If clicking own piece, reselect
            if ((side === "white" && code && code.startsWith('w') && playerIndex === 0) ||
                (side === "black" && code && code.startsWith('b') && playerIndex === 1)) {
              chess.selected = { row, col };
              chess.highlights = getLegalMovesFull(chess.board, row, col, side, chess, true);
            } else {
              chess.selected = null;
              chess.highlights = [];
            }
          }
        }
        match.chess = chess;
        return match;
      });
    }

    // --- Chess engine functions ---
    // Helper: insideBoard
    function insideBoard(r,c) { return r>=0&&r<8&&c>=0&&c<8; }

    // Helper: deepCopyBoard
    function deepCopyBoard(board) { return board.map(row => row.slice()); }

    // Main legal moves function (all rules)
    function getLegalMovesFull(board, r, c, turn, chess, markSpecials=false) {
      const code = board[r][c];
      if (!code) return [];
      const side = code[0] === 'w' ? 'white' : 'black';
      if (side !== turn) return [];
      const moves = [];
      let pinnedSquares = [];
      let forkSquares = [];

      // All candidate moves
      let candidates = [];
      if (code[1] === "P") {
        const dir = side === "white" ? -1 : 1;
        const r2 = r + dir;
        // Forward
        if (insideBoard(r2, c) && !board[r2][c]) candidates.push({ row: r2, col: c });
        // Double move
        if ((side === "white" && r===6) || (side === "black" && r===1)) {
          const r3 = r + 2*dir;
          if (insideBoard(r3, c) && !board[r2][c] && !board[r3][c]) candidates.push({ row: r3, col: c });
        }
        // Captures
        for (const dc of [-1,1]) {
          const c2 = c+dc;
          if (insideBoard(r2, c2) && board[r2][c2] && board[r2][c2][0] !== code[0])
            candidates.push({ row: r2, col: c2 });
          // En passant
          if (insideBoard(r, c2) && chess.lastMove && chess.lastMove.moving[1]==="P" &&
              Math.abs(chess.lastMove.from.row-chess.lastMove.to.row)===2 &&
              chess.lastMove.to.row===r && chess.lastMove.to.col===c2 &&
              board[r][c2] && board[r][c2][0]!==code[0]) {
            candidates.push({ row: r2, col: c2, enPassant:true });
          }
        }
      }
      if (code[1] === "N") {
        [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr,dc]) => {
          const r2=r+dr,c2=c+dc;
          if (insideBoard(r2,c2) && (!board[r2][c2] || board[r2][c2][0]!==code[0]))
            candidates.push({ row: r2, col: c2 });
        });
      }
      if (code[1] === "B" || code[1] === "Q") {
        for (const [dr,dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
          for (let k=1;k<8;k++) {
            const r2=r+dr*k, c2=c+dc*k;
            if (!insideBoard(r2,c2)) break;
            if (!board[r2][c2]) candidates.push({ row: r2, col: c2 });
            else { if(board[r2][c2][0]!==code[0]) candidates.push({ row: r2, col: c2 }); break; }
          }
        }
      }
      if (code[1] === "R" || code[1] === "Q") {
        for (const [dr,dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          for (let k=1;k<8;k++) {
            const r2=r+dr*k, c2=c+dc*k;
            if (!insideBoard(r2,c2)) break;
            if (!board[r2][c2]) candidates.push({ row: r2, col: c2 });
            else { if(board[r2][c2][0]!==code[0]) candidates.push({ row: r2, col: c2 }); break; }
          }
        }
      }
      if (code[1] === "K") {
        for (const dr of [-1,0,1]) for (const dc of [-1,0,1]) {
          if (dr===0&&dc===0) continue;
          const r2=r+dr,c2=c+dc;
          if (insideBoard(r2,c2) && (!board[r2][c2]||board[r2][c2][0]!==code[0]))
            candidates.push({ row: r2, col: c2 });
        }
        // Castling
        if (canCastle(board, side, "king")) candidates.push({ row: r, col: 6, castle:true });
        if (canCastle(board, side, "queen")) candidates.push({ row: r, col: 2, castle:true });
      }

      // Filter only legal ones (no self-check)
      for (const mv of candidates) {
        const simBoard = deepCopyBoard(board);
        // Apply move to simBoard
        simBoard[mv.row][mv.col] = code;
        simBoard[r][c] = "";
        if (code[1]==="K" && Math.abs(mv.col-c)>=2) {
          // Simulate castling rook
          if (mv.col===6) { simBoard[r][5]=code[0]+"R"; simBoard[r][7]=""; }
          else if (mv.col===2) { simBoard[r][3]=code[0]+"R"; simBoard[r][0]=""; }
        }
        // En passant
        if (mv.enPassant) {
          simBoard[r][mv.col]="";
        }
        // Promotion not handled here, always legal
        // Check if own king attacked
        if (!isKingAttacked(simBoard, side)) moves.push(mv);
      }

      if (markSpecials) {
        // Find pinned/forked (basic version)
        if (code[1] !== "K") {
          pinnedSquares = findPinned(board, side);
          forkSquares = findFork(board, side, r, c);
        }
      }
      if (markSpecials) {
        chess.pinned = pinnedSquares;
        chess.forked = forkSquares;
      }
      return moves;
    }

    // --- Utility functions for chess rules ---
    // King is attacked?
    function isKingAttacked(board, side) {
      let kingPos = null;
      for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
        if (board[r][c]===((side==="white")?"wK":"bK")) kingPos={row:r,col:c};
      }
      if (!kingPos) return true;
      const opp = side==="white"?"b":"w";
      // Check all opponent moves to see if king attacked
      for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
        const code = board[r][c];
        if (code && code[0]===opp) {
          const moves = getLegalMovesFull(board, r, c, opp==="w"?"white":"black", {}, false);
          if (moves.some(mv => mv.row===kingPos.row && mv.col===kingPos.col)) return true;
        }
      }
      return false;
    }
    // Checkmate
    function isCheckmate(board, side) {
      for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
        const code = board[r][c];
        if (code && ((side==="white" && code[0]==="w")||(side==="black"&&code[0]==="b"))) {
          const moves = getLegalMovesFull(board, r, c, side, {}, false);
          if (moves.length>0) return false;
        }
      }
      return true;
    }
    // Find pinned pieces (basic)
    function findPinned(board, side) {
      // For each piece, see if moving exposes king to attack
      const result = [];
      for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
        const code = board[r][c];
        if (code && ((side==="white" && code[0]==="w")||(side==="black"&&code[0]==="b")) && code[1]!=="K") {
          const moves = getLegalMovesFull(board, r, c, side, {}, false);
          let pinned = true;
          for(const mv of moves) {
            const simBoard = deepCopyBoard(board);
            simBoard[mv.row][mv.col]=code;
            simBoard[r][c]="";
            if (!isKingAttacked(simBoard, side)) { pinned=false; break; }
          }
          if (pinned) result.push({row:r,col:c});
        }
      }
      return result;
    }
    // Find forks (basic: knight forks king and rook/queen)
    function findFork(board, side, r, c) {
      const code = board[r][c];
      if (!code) return [];
      if (code[1]!=="N") return [];
      const opp = side==="white"?"b":"w";
      const targets = [];
      [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr,dc]) => {
        const r2=r+dr,c2=c+dc;
        if (insideBoard(r2,c2) && board[r2][c2] && board[r2][c2][0]===opp) {
          if (["K","Q","R"].includes(board[r2][c2][1])) targets.push({row:r2,col:c2});
        }
      });
      return targets;
    }
    // Castling
    function canCastle(board, color, side) {
      // No check, no pieces between, both have not moved
      const r = color==="white"?7:0;
      const king = board[r][4];
      if (!king||king[1]!=="K") return false;
      // No pieces between king and rook, not in check
      if (side==="king") {
        if (board[r][7]!==(color[0]+"R")) return false;
        for(let c=5;c<=6;c++) if (board[r][c]) return false;
        // No check on passing squares
        for(let c=4;c<=6;c++) {
          const simBoard = deepCopyBoard(board);
          simBoard[r][c]=color[0]+"K";
          simBoard[r][4]="";
          if (isKingAttacked(simBoard, color)) return false;
        }
        return true;
      }
      if (side==="queen") {
        if (board[r][0]!==(color[0]+"R")) return false;
        for(let c=1;c<=3;c++) if (board[r][c]) return false;
        for(let c=2;c<=4;c++) {
          const simBoard = deepCopyBoard(board);
          simBoard[r][c]=color[0]+"K";
          simBoard[r][4]="";
          if (isKingAttacked(simBoard, color)) return false;
        }
        return true;
      }
      return false;
    }
    // Apply check/checkmate states to board
    function applyCheckStates(chess) {
      const opp = chess.turn;
      const board = chess.board;
      chess.check = isKingAttacked(board, opp);
      chess.checkmate = chess.check && isCheckmate(board, opp);
    }

    // --- Promotion modal ---
    function showPromotionModal(prom, cb) {
      promotionCallback = cb;
      promotionModal.classList.add("active");
      promotionOptions.innerHTML = "";
      const opts = ["Q","R","B","N"];
      opts.forEach(piece=>{
        const img = document.createElement("img");
        img.className = "promotion-piece";
        img.src = getPieceSVG(prom.color + piece);
        img.onclick = ()=>{ promotionModal.classList.remove("active"); cb(piece); };
        promotionOptions.appendChild(img);
      });
    }
    function hidePromotionModal() {
      promotionModal.classList.remove("active");
      promotionOptions.innerHTML = "";
      promotionCallback = null;
    }

    function restartGame() {
      if (!matchId) return;
      db.ref('matches/' + matchId).remove();
      gameBoard.innerHTML = '';
      statusEl.textContent = '';
      winnerMessage.textContent = '';
      restartBtn.style.display = 'none';
      matchLinkEl.textContent = '';
      finished = false;
      startBtn.disabled = false;
    }

    window.addEventListener("resize", ()=>{});

  </script>
</body>
    </html>
