<!DOCTYPE html>
<html lang="en" class="bg-gray-900 text-white">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Online Chess Multiplayer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .board-grid {
      margin: 0 auto;
      display: grid;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 0 8px #222;
      gap: 0px;
      max-width: 98vw;
    }
    .chess-square {
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
      user-select: none;
      border: 1px solid #333;
      box-sizing: border-box;
      transition: background 0.2s;
    }
    .chess-square.light { background: #f0d9b5; }
    .chess-square.dark { background: #b58863; }
    .chess-square.selected { outline: 3px solid yellow; }
    .chess-square.highlight { background: rgba(255,255,0,0.4); }
    .piece { width: 90%; height: 90%; user-select: none; }
    #status { font-size: 1.3rem; font-weight: bold; margin: 1rem 0; text-align: center; padding: 0.7rem 1.4rem; border-radius: 8px; }
    .white-turn { background: #4a90e2; box-shadow: 0 0 12px #4a90e2;}
    .black-turn { background: #e94e77; box-shadow: 0 0 12px #e94e77;}
    #winner-message { font-size: 1.9rem; font-weight: 800; text-align: center; margin: 1.5rem 0; color: #00ff00; text-shadow: 0 0 6px #00ff00;}
    #restart { display: none; margin: 0 auto 2rem auto; padding: 12px 30px; font-size: 1.2rem; font-weight: 700; background: #555; border: none; border-radius: 10px; color: white; cursor: pointer;}
    #restart:hover { background: #777;}
    #modal { position: fixed; inset: 0; background: rgba(0,0,0,0.75); display: none; align-items: center; justify-content: center; z-index: 1000; }
    #modal.active { display: flex; }
    #modal-content { background: #111; padding: 2rem; border-radius: 10px; max-width: 400px; width: 90%; color: white; text-align: center; }
    .loader { border: 5px solid #444; border-top: 5px solid #00ff00; border-radius: 50%; width: 50px; height: 50px; animation: spin 1.5s linear infinite; margin: 0 auto 1rem auto; }
    @keyframes spin { 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);} }
    /* Responsive Board */
    @media (max-width: 600px) {
      .board-grid { max-width: 95vw; }
      .chess-square { font-size: 1.1rem !important; }
    }
  </style>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
</head>
<body class="min-h-screen flex flex-col">

  <div id="auth-screen" class="flex-grow flex flex-col items-center justify-center p-4">
    <h1 class="text-5xl font-extrabold mb-8">Online Chess Multiplayer</h1>
    <button id="signin-btn" class="bg-blue-600 hover:bg-blue-700 px-8 py-3 rounded-lg font-semibold shadow" onclick="signIn()">Sign in with Google</button>
  </div>

  <div id="app" class="hidden flex-grow flex flex-col">
    <header class="flex justify-between items-center p-4 border-b border-gray-700 relative">
      <div><span id="username" class="font-bold text-xl"></span> | Rating: <span id="rating" class="font-semibold">0</span></div>
    </header>
    <main class="flex-grow overflow-auto p-4">
      <section id="screen-home" class="space-y-6">
        <div class="flex justify-center space-x-4 mb-6">
          <button id="mode-2" class="mode-btn px-5 py-2 border border-white rounded active" onclick="selectMode(2)">2 Players</button>
        </div>
        <div class="flex justify-center mb-6">
          <button id="start-btn" class="bg-green-600 hover:bg-green-700 px-8 py-3 rounded-lg font-semibold" onclick="startMatch()">Start Online Game</button>
        </div>
        <div id="match-link" class="text-center mb-6 text-sm text-blue-400 break-all"></div>
        <div id="status" class="white-turn text-white"></div>
        <div id="game-board" class="mx-auto mt-2 mb-2" style="user-select:none;"></div>
        <button id="restart" onclick="restartGame()">Restart Game</button>
        <div id="winner-message"></div>
      </section>
    </main>
  </div>

  <div id="modal">
    <div id="modal-content">
      <h2 class="text-2xl mb-4">Waiting for other player...</h2>
      <div class="loader"></div>
      <p id="players-found" class="mb-4 font-semibold text-lg">Players found: 1/2</p>
    </div>
  </div>

  <script>
    // ==== FIREBASE CONFIGURATION ====
    const firebaseConfig = {
      apiKey: "AIzaSyB-5CakD79CthsI-_vcqblOCN1sXS6U8u8",
      authDomain: "dot-and-box-90d27.firebaseapp.com",
      databaseURL: "https://dot-and-box-90d27-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "dot-and-box-90d27",
      storageBucket: "dot-and-box-90d27.appspot.com",
      messagingSenderId: "913945926983",
      appId: "1:913945926983:web:b4c00c2cffff5b6fa7c062"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    // UI Elements
    const authScreen = document.getElementById('auth-screen');
    const app = document.getElementById('app');
    const usernameEl = document.getElementById('username');
    const ratingEl = document.getElementById('rating');
    const startBtn = document.getElementById('start-btn');
    const matchLinkEl = document.getElementById('match-link');
    const statusEl = document.getElementById('status');
    const gameBoard = document.getElementById('game-board');
    const restartBtn = document.getElementById('restart');
    const winnerMessage = document.getElementById('winner-message');
    const modal = document.getElementById('modal');
    const playersFoundEl = document.getElementById('players-found');

    // GLOBALS
    let currentUser = null;
    let userData = null;
    let matchId = null;
    let isMyTurn = false;
    let players = [];
    let playersInfo = {};
    let finished = false;
    let playerIndex = null;
    let matchCleanupScheduled = false;

    // ==== AUTH & USER ====
    auth.onAuthStateChanged(async user => {
      if (user) {
        currentUser = user;
        await loadUserData();
        authScreen.style.display = 'none';
        app.classList.remove('hidden');
        showScreen('home');
        setupInitialUI();
      } else {
        currentUser = null;
        userData = null;
        app.classList.add('hidden');
        authScreen.style.display = 'flex';
      }
    });

    async function loadUserData() {
      if (!currentUser) return;
      const snapshot = await db.ref('users/' + currentUser.uid).get();
      if (snapshot.exists()) {
        userData = snapshot.val();
      } else {
        userData = {
          username: currentUser.displayName || 'Anonymous',
          rating: 1000,
        };
        await db.ref('users/' + currentUser.uid).set(userData);
      }
      usernameEl.textContent = userData.username;
      ratingEl.textContent = userData.rating || 0;
    }

    function signIn() {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider);
    }

    function showScreen(name) {
      // Only home screen in chess
    }

    function setupInitialUI() {
      restartBtn.style.display = 'none';
      winnerMessage.textContent = '';
      statusEl.textContent = '';
      matchLinkEl.textContent = '';
      finished = false;
    }

    function selectMode(n) {
      // Chess only 2 player
    }

    function startMatch() {
      if (!currentUser) return alert('Please sign in first.');
      startBtn.disabled = true;
      createOrJoinMatch();
    }

    async function createOrJoinMatch() {
      modal.classList.add('active');
      playersFoundEl.textContent = `Players found: 1/2`;
      let openMatchId = null;
      const matchesSnapshot = await db.ref('matches').orderByChild('mode').equalTo(2).get();
      if (matchesSnapshot.exists()) {
        matchesSnapshot.forEach(matchSnap => {
          const m = matchSnap.val();
          if (!m.started && Object.keys(m.players || {}).length < 2) {
            openMatchId = matchSnap.key;
            return true;
          }
        });
      }
      if (openMatchId) {
        matchId = openMatchId;
        await joinMatch(matchId);
      } else {
        const newMatchRef = db.ref('matches').push();
        matchId = newMatchRef.key;
        const playersObj = {};
        playersObj[currentUser.uid] = {
          username: userData.username,
          rating: userData.rating || 0,
        };
        await newMatchRef.set({
          mode: 2,
          started: false,
          players: playersObj,
          chess: getInitialChessState(),
          turnIndex: 0,
        });
        await waitForPlayers(matchId);
      }
    }

    async function joinMatch(id) {
      const matchRef = db.ref('matches/' + id);
      const matchSnap = await matchRef.get();
      if (!matchSnap.exists()) {
        alert('Match not found');
        modal.classList.remove('active');
        startBtn.disabled = false;
        return;
      }
      const match = matchSnap.val();
      if (match.started) {
        alert('Match already started');
        modal.classList.remove('active');
        startBtn.disabled = false;
        return;
      }
      if (match.players && Object.keys(match.players).includes(currentUser.uid)) {
        listenToMatch(matchId);
        return;
      }
      await matchRef.child('players/' + currentUser.uid).set({
        username: userData.username,
        rating: userData.rating || 0,
      });
      await waitForPlayers(id);
    }

    async function waitForPlayers(id) {
      const matchRef = db.ref('matches/' + id);
      matchRef.on('value', snapshot => {
        if (!snapshot.exists()) return;
        const data = snapshot.val();
        players = Object.keys(data.players || {});
        playersInfo = data.players || {};
        playersFoundEl.textContent = `Players found: ${players.length}/2`;
        if (players.length === 2 && !data.started) {
          matchRef.update({ started: true });
        }
        if (data.started) {
          modal.classList.remove('active');
          listenToMatch(id);
        }
      });
    }

    function listenToMatch(id) {
      matchId = id;
      const matchRef = db.ref('matches/' + id);
      finished = false;
      matchRef.on('value', async snapshot => {
        if (!snapshot.exists()) return;
        const gameData = snapshot.val();
        players = Object.keys(gameData.players || {});
        playersInfo = gameData.players || {};
        playerIndex = players.indexOf(currentUser.uid);
        isMyTurn = (gameData.turnIndex === playerIndex);
        updateTurnStatus(gameData);
        renderGameBoard(gameData.chess);
        if (gameData.chess.status === "finished" && !finished) {
          finished = true;
          setTimeout(() => {
            winnerMessage.textContent = gameData.chess.winner === players[playerIndex] ? 'You win!' : `${playersInfo[gameData.chess.winner].username} wins!`;
            restartBtn.style.display = 'block';
            statusEl.textContent = '';
            matchRef.off('value');
            scheduleMatchCleanup();
          }, 500);
        }
      });
    }

    function scheduleMatchCleanup() {
      if (!matchId || matchCleanupScheduled) return;
      matchCleanupScheduled = true;
      setTimeout(() => {
        db.ref('matches/' + matchId).remove();
        matchId = null;
        matchCleanupScheduled = false;
      }, 1200);
    }

    function updateTurnStatus(gameData) {
      if (!gameData) return;
      const currentTurnIndex = gameData.turnIndex || 0;
      isMyTurn = (playerIndex === currentTurnIndex);
      const turnPlayer = players[currentTurnIndex];
      const turnName = playersInfo[turnPlayer]?.username || 'Unknown';
      statusEl.textContent = isMyTurn ? `Your turn (${turnName})` : `Waiting for ${turnName}`;
      statusEl.className = currentTurnIndex === 0 ? 'white-turn' : 'black-turn';
    }

    function getInitialChessState() {
      return {
        board: [
          ["bR","bN","bB","bQ","bK","bB","bN","bR"],
          ["bP","bP","bP","bP","bP","bP","bP","bP"],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["wP","wP","wP","wP","wP","wP","wP","wP"],
          ["wR","wN","wB","wQ","wK","wB","wN","wR"]
        ],
        turn: "white",
        selected: null,
        highlights: [],
        status: "active",
        winner: null
      };
    }

    function renderGameBoard(chess) {
      if (!chess) return;
      const board = chess.board;
      let boardHTML = `<div class="board-grid" style="
        grid-template-columns: repeat(8, 48px);
        grid-template-rows: repeat(8, 48px);
        width: ${48*8}px;
      ">`;
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const light = (r + c) % 2 === 0 ? 'light' : 'dark';
          boardHTML += `<div class="chess-square ${light}" data-row="${r}" data-col="${c}"></div>`;
        }
      }
      boardHTML += '</div>';
      gameBoard.innerHTML = boardHTML;
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const code = board[r][c];
          if (code) {
            const img = document.createElement("img");
            img.className = "piece";
            img.src = getPieceSVG(code);
            img.draggable = false;
            const squareDiv = document.querySelector(`.chess-square[data-row="${r}"][data-col="${c}"]`);
            squareDiv.appendChild(img);
          }
        }
      }
      if (chess.selected) {
        const selectedDiv = document.querySelector(`.chess-square[data-row="${chess.selected.row}"][data-col="${chess.selected.col}"]`);
        if (selectedDiv) selectedDiv.classList.add("selected");
      }
      chess.highlights.forEach(move => {
        const moveDiv = document.querySelector(`.chess-square[data-row="${move.row}"][data-col="${move.col}"]`);
        if (moveDiv) moveDiv.classList.add("highlight");
      });
      document.querySelectorAll('.chess-square').forEach(sq => {
        sq.onclick = () => handleSquareClick(+sq.dataset.row, +sq.dataset.col);
        sq.style.cursor = isMyTurn ? 'pointer' : 'not-allowed';
      });
    }

    function getPieceSVG(code) {
      // Use piece SVG from your "pieces" folder, fallback to Unicode
      const unicodes = {
        wK: "♔", wQ: "♕", wR: "♖", wB: "♗", wN: "♘", wP: "♙",
        bK: "♚", bQ: "♛", bR: "♜", bB: "♝", bN: "♞", bP: "♟"
      };
      return `https://upload.wikimedia.org/wikipedia/commons/${{
        wK: "4/42/Chess_klt45.svg",
        wQ: "1/15/Chess_qlt45.svg",
        wR: "7/72/Chess_rlt45.svg",
        wB: "b/b1/Chess_blt45.svg",
        wN: "7/70/Chess_nlt45.svg",
        wP: "4/45/Chess_plt45.svg",
        bK: "f/f1/Chess_kdt45.svg",
        bQ: "4/47/Chess_qdt45.svg",
        bR: "f/ff/Chess_rdt45.svg",
        bB: "9/98/Chess_bdt45.svg",
        bN: "e/ef/Chess_ndt45.svg",
        bP: "c/c7/Chess_pdt45.svg"
      }[code]}`;
    }

    function handleSquareClick(row, col) {
      if (!isMyTurn || finished) return;
      db.ref('matches/' + matchId).transaction(match => {
        if (!match || match.chess.status === "finished") return;
        const chess = match.chess;
        if (!chess.selected) {
          const code = chess.board[row][col];
          if ((chess.turn === "white" && code && code.startsWith('w') && playerIndex === 0) ||
              (chess.turn === "black" && code && code.startsWith('b') && playerIndex === 1)) {
            chess.selected = { row, col };
            chess.highlights = getLegalMoves(chess.board, row, col, chess.turn);
          }
        } else {
          const move = chess.highlights.find(mv => mv.row === row && mv.col === col);
          if (move) {
            // Apply move
            const from = chess.selected;
            const to = { row, col };
            const origFrom = chess.board[from.row][from.col];
            const origTo = chess.board[to.row][to.col];
            chess.board[from.row][from.col] = "";
            chess.board[to.row][to.col] = origFrom;
            // Pawn promotion, castling, en passant skip for brevity
            chess.turn = chess.turn === "white" ? "black" : "white";
            chess.selected = null;
            chess.highlights = [];
            match.turnIndex = (match.turnIndex + 1) % 2;
            // Checkmate/stalemate detection not implemented here for brevity
          } else {
            // Reselect if it's your piece
            const code = chess.board[row][col];
            if ((chess.turn === "white" && code && code.startsWith('w') && playerIndex === 0) ||
                (chess.turn === "black" && code && code.startsWith('b') && playerIndex === 1)) {
              chess.selected = { row, col };
              chess.highlights = getLegalMoves(chess.board, row, col, chess.turn);
            } else {
              chess.selected = null;
              chess.highlights = [];
            }
          }
        }
        match.chess = chess;
        return match;
      });
    }

    function getLegalMoves(board, r, c, turn) {
      // Minimal: Only normal moves, no special chess rules for brevity
      const code = board[r][c];
      if (!code) return [];
      const side = code[0] === 'w' ? 'white' : 'black';
      if (side !== turn) return [];
      const moves = [];
      if (code[1] === "P") {
        const dir = side === "white" ? -1 : 1;
        const r2 = r + dir;
        if (r2 >= 0 && r2 < 8 && !board[r2][c]) moves.push({ row: r2, col: c });
        for (const dc of [-1, 1]) {
          const c2 = c + dc;
          if (c2 >= 0 && c2 < 8 && board[r2][c2] && board[r2][c2][0] !== code[0])
            moves.push({ row: r2, col: c2 });
        }
      }
      // Knight
      if (code[1] === "N") {
        const deltas = [
          [-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]
        ];
        deltas.forEach(([dr,dc]) => {
          const r2 = r+dr, c2 = c+dc;
          if (r2>=0 && r2<8 && c2>=0 && c2<8 && (!board[r2][c2] || board[r2][c2][0]!==code[0]))
            moves.push({ row: r2, col: c2 });
        });
      }
      // Bishop
      if (code[1] === "B" || code[1] === "Q") {
        for (const [dr,dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
          for (let k=1;k<8;k++) {
            const r2=r+dr*k, c2=c+dc*k;
            if (r2<0||r2>=8||c2<0||c2>=8) break;
            if (!board[r2][c2]) moves.push({ row: r2, col: c2 });
            else { if(board[r2][c2][0]!==code[0]) moves.push({ row: r2, col: c2 }); break; }
          }
        }
      }
      // Rook
      if (code[1] === "R" || code[1] === "Q") {
        for (const [dr,dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          for (let k=1;k<8;k++) {
            const r2=r+dr*k, c2=c+dc*k;
            if (r2<0||r2>=8||c2<0||c2>=8) break;
            if (!board[r2][c2]) moves.push({ row: r2, col: c2 });
            else { if(board[r2][c2][0]!==code[0]) moves.push({ row: r2, col: c2 }); break; }
          }
        }
      }
      // King
      if (code[1] === "K") {
        for (const dr of [-1,0,1]) for (const dc of [-1,0,1]) {
          if (dr===0&&dc===0) continue;
          const r2=r+dr, c2=c+dc;
          if (r2>=0&&r2<8&&c2>=0&&c2<8&&(!board[r2][c2]||board[r2][c2][0]!==code[0]))
            moves.push({ row: r2, col: c2 });
        }
      }
      return moves;
    }

    function restartGame() {
      if (!matchId) return;
      db.ref('matches/' + matchId).remove();
      gameBoard.innerHTML = '';
      statusEl.textContent = '';
      winnerMessage.textContent = '';
      restartBtn.style.display = 'none';
      matchLinkEl.textContent = '';
      finished = false;
      startBtn.disabled = false;
    }

    window.addEventListener("resize", ()=>{});

  </script>
</body>
      </html>
