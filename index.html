<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Online Multiplayer Chess</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background-color: #222;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 1rem;
      position: relative;
    }
    h1 {
      margin-bottom: 1rem;
      font-size: 1.5rem;
      text-align: center;
    }
    .captured {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      min-height: 2rem;
      margin: 0.5rem 0;
      gap: 0.25rem;
    }
    .captured img {
      width: 2rem;
      height: 2rem;
    }
    .clock-container {
      width: 100%;
      max-width: 480px;
      display: flex;
      justify-content: center;
      margin: 0.25rem 0;
    }
    .clock {
      width: 100%;
      max-width: 200px;
      padding: 0.5rem 1rem;
      text-align: center;
      border: 2px solid white;
      border-radius: 4px;
      font-family: monospace;
      background-color: #333;
      color: #eee;
      font-size: 1rem;
      margin: 30px 0 30px 0;
    }
    .active-clock {
      background-color: white;
      color: black;
      font-size: 1.5rem;
      border-color: #fff;
    }
    .inactive-clock {
      background-color: #333;
      color: #aaa;
      font-size: 1rem;
      border-color: #555;
    }
    #board-container {
      width: 100%;
      max-width: 480px;
      aspect-ratio: 1;
      border: 2px solid white;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
    }
    .square {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0;
      cursor: pointer;
    }
    .square[data-col="0"].light { background-color: #f0d9b5; }
    .square[data-col="0"].dark  { background-color: #b58863; }
    .square[data-col="1"].light { background-color: #f0d9b5; }
    .square[data-col="1"].dark  { background-color: #b58863; }
    .square[data-col="2"].light { background-color: #f0d9b5; }
    .square[data-col="2"].dark  { background-color: #b58863; }
    .square[data-col="3"].light { background-color: #f0d9b5; }
    .square[data-col="3"].dark  { background-color: #b58863; }
    .square[data-col="4"].light { background-color: #f0d9b5; }
    .square[data-col="4"].dark  { background-color: #b58863; }
    .square[data-col="5"].light { background-color: #f0d9b5; }
    .square[data-col="5"].dark  { background-color: #b58863; }
    .square[data-col="6"].light { background-color: #f0d9b5; }
    .square[data-col="6"].dark  { background-color: #b58863; }
    .square[data-col="7"].light { background-color: #f0d9b5; }
    .square[data-col="7"].dark  { background-color: #b58863; }
    .selected {
      outline: 3px solid yellow;
    }
    .highlight {
      background-color: rgba(255, 255, 0, 0.4);
    }
    img.piece {
      width: 90%;
      height: 90%;
      user-select: none;
      -webkit-user-drag: none;
    }
    #winner-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #winner-modal .modal-content {
      background-color: #111;
      padding: 2rem;
      border: 2px solid white;
      border-radius: 8px;
      text-align: center;
      max-width: 80%;
      color: #4d94ff;
    }
    #winner-modal .modal-content h2 {
      margin-bottom: 1rem;
      font-size: 2rem;
      color: #ff4d4d;
    }
    #winner-modal .modal-content button {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: #fff;
      color: #000;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #winner-modal .modal-content button:hover {
      background-color: #ddd;
    }
    #home-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: #111;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    #home-screen h1 {
      font-size: 2.2rem;
      margin-bottom: 2rem;
    }
    #home-screen button {
      background: #fff;
      color: #222;
      font-size: 1.1rem;
      padding: 0.7rem 2.5rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      margin-top: 1rem;
      font-weight: bold;
      min-width: 130px;
    }
    #home-screen button:disabled {
      background: #aaa;
      color: #444;
      cursor: not-allowed;
    }
    #waiting-message {
      margin-top: 2rem;
      font-size: 1.2rem;
      color: #4d94ff;
    }
    #info-bar {
      margin: 0.7rem 0;
      font-size: 1rem;
      color: #4d94ff;
      text-align: center;
      width: 100%;
    }
    #user-bar {
      margin: 0.7rem 0;
      font-size: 1rem;
      color: #ffe04d;
      text-align: center;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #user-bar span {
      display: flex;
      align-items: center;
    }
    #user-bar img {
      width: 1.8em;
      height: 1.8em;
      border-radius: 50%;
      margin-right: 0.5em;
    }
  </style>
  <!-- Firebase scripts (no library, use CDN) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
</head>
<body>
  <div id="home-screen">
    <h1>♟️ Online Chess ♟️</h1>
    <button id="google-signin-btn">Sign in with Google</button>
    <div id="signedin-user" style="display:none; margin-top:1rem; font-size:1.1em;"></div>
    <button id="play-btn" style="display:none;">Play</button>
    <div id="waiting-message" style="display:none;">Waiting for another player...</div>
  </div>
  <div id="user-bar" style="display:none;">
    <span id="user-white"></span>
    <span id="user-black"></span>
  </div>
  <div id="info-bar" style="display:none;"></div>
  <div id="captured-white" class="captured" style="display:none;"></div>
  <div class="clock-container" style="display:none;">
    <div id="black-clock" class="clock active-clock">10:00</div>
  </div>
  <div id="board-container" style="display:none;"></div>
  <div class="clock-container" style="display:none;">
    <div id="white-clock" class="clock inactive-clock">10:00</div>
  </div>
  <div id="captured-black" class="captured" style="display:none;"></div>
  <div id="winner-modal">
    <div class="modal-content">
      <h2 id="winner-text">Winner: </h2>
      <button id="modal-restart-btn">Play Again</button>
    </div>
  </div>
  <script>
    // ===== FIREBASE CONFIGURATION =====
    const firebaseConfig = {
  apiKey: "AIzaSyDWbWkOSY5IA3LQuSjW5pFD0XQOWmK8mAE",
  authDomain: "chess-online-ac582.firebaseapp.com",
  databaseURL: "https://chess-online-ac582-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "chess-online-ac582",
  storageBucket: "chess-online-ac582.firebasestorage.app",
  messagingSenderId: "804954664189",
  appId: "1:804954664189:web:b45d833a39337ce8a6e294"
};
    firebase.initializeApp(firebaseConfig);
   const db = firebase.database();
    const auth = firebase.auth();

    // ==== DOM refs ====
    const homeScreen = document.getElementById("home-screen");
    const googleSignInBtn = document.getElementById("google-signin-btn");
    const playBtn = document.getElementById("play-btn");
    const signedInUserDiv = document.getElementById("signedin-user");
    const waitingMsg = document.getElementById("waiting-message");
    const infoBar = document.getElementById("info-bar");
    const boardContainer = document.getElementById("board-container");
    const modal = document.getElementById("winner-modal");
    const winnerText = document.getElementById("winner-text");
    const modalRestartBtn = document.getElementById("modal-restart-btn");
    const capturedWhiteDiv = document.getElementById("captured-white");
    const capturedBlackDiv = document.getElementById("captured-black");
    const whiteClockDiv = document.getElementById("white-clock");
    const blackClockDiv = document.getElementById("black-clock");
    const clockContainers = document.querySelectorAll('.clock-container');
    const userBar = document.getElementById("user-bar");
    const userWhite = document.getElementById("user-white");
    const userBlack = document.getElementById("user-black");

    // ========== GAME STATE VARS ==========
    let boardState = [];
    let selectedSquare = null;
    let validMoves = [];
    let turn = "white";
    let castlingRights = { wK: true, wQ: true, bK: true, bQ: true };
    let enPassantTarget = null;
    let halfmoveClock = 0;
    let fullmoveNumber = 1;
    let whiteTime = 600;
    let blackTime = 600;
    let clockInterval = null;
    let mySide = null; // "white" or "black"
    let gameId = null;
    let isMyTurn = false;
    let winner = null;
    let gameRef = null;
    let user = null;
    let playerInfo = {white: null, black: null};
    let myUserDbKey = null;

    // Piece images mapping (relative to root!)
    const pieceImages = {
      wP: "pieces/wP.svg",
      wR: "pieces/wR.svg",
      wN: "pieces/wN.svg",
      wB: "pieces/wB.svg",
      wQ: "pieces/wQ.svg",
      wK: "pieces/wK.svg",
      bP: "pieces/bP.svg",
      bR: "pieces/bR.svg",
      bN: "pieces/bN.svg",
      bB: "pieces/bB.svg",
      bQ: "pieces/bQ.svg",
      bK: "pieces/bK.svg",
    };

    // ============= GOOGLE SIGN IN ===========
    function updateUIForUser(user) {
      if (user) {
        signedInUserDiv.style.display = "";
        signedInUserDiv.innerHTML = `<img src="${user.photoURL}" style="width:2em;height:2em;border-radius:1em;margin-right:0.5em;vertical-align:middle;">${user.displayName}`;
        playBtn.style.display = "";
        googleSignInBtn.style.display = "none";
      } else {
        signedInUserDiv.style.display = "none";
        playBtn.style.display = "none";
        googleSignInBtn.style.display = "";
      }
    }
    googleSignInBtn.onclick = function() {
      var provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).then((result) => {
        user = result.user;
        updateUIForUser(user);
      }).catch((error) => {
        alert("Failed to sign in: " + error.message);
      });
    };
    auth.onAuthStateChanged(function(u) {
      user = u;
      updateUIForUser(user);
    });

    // ========== HOME SCREEN & MATCHMAKING ==========
    playBtn.onclick = function() {
      playBtn.disabled = true;
      waitingMsg.style.display = "";
      // Find a waiting game or make new
      db.ref("chess-matches/").once("value").then(snap => {
        let found = false;
        let foundKey = null;
        snap.forEach(child => {
          let val = child.val();
          if (val.status === "waiting" && val.playerWhite && val.playerWhite.uid !== user.uid) {
            found = true;
            foundKey = child.key;
          }
        });
        if (found) {
          // Join as black
          joinGame(foundKey);
        } else {
          // Create new as white
          createGame();
        }
      });
    };

    function createGame() {
      let id = "game_" + Math.random().toString(36).substr(2,9);
      gameId = id;
      mySide = "white";
      isMyTurn = true;
      playerInfo.white = {
        name: user.displayName,
        photo: user.photoURL,
        uid: user.uid
      };
      let initialState = {
        board: [
          ["bR","bN","bB","bQ","bK","bB","bN","bR"],
          ["bP","bP","bP","bP","bP","bP","bP","bP"],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["","","","","","","",""],
          ["wP","wP","wP","wP","wP","wP","wP","wP"],
          ["wR","wN","wB","wQ","wK","wB","wN","wR"]
        ],
        turn: "white",
        castling: { wK: true, wQ: true, bK: true, bQ: true },
        enPassant: null,
        whiteTime: 600,
        blackTime: 600,
        moves: [],
        status: "waiting",
        winner: null,
        playerWhite: playerInfo.white,
        playerBlack: null
      };
      db.ref("chess-matches/"+id).set(initialState).then(()=>{
        waitForPlayer(id);
      });
    }
    function waitForPlayer(id) {
      db.ref("chess-matches/"+id).on("value", snap=>{
        let val = snap.val();
        if (!val) return;
        if (val.status === "waiting") {
          waitingMsg.innerText = "Waiting for another player...";
        } else if (val.status==="playing") {
          gameRef = db.ref("chess-matches/"+id);
          playerInfo.white = val.playerWhite;
          playerInfo.black = val.playerBlack;
          startGame(val);
          db.ref("chess-matches/"+id).off();
        }
      });
    }
    function joinGame(id) {
      mySide = "black";
      isMyTurn = false;
      gameId = id;
      playerInfo.black = {
        name: user.displayName,
        photo: user.photoURL,
        uid: user.uid
      };
      // Mark game as started
      db.ref("chess-matches/"+id).transaction(val=>{
        if (!val || val.status !== "waiting") return;
        val.status = "playing";
        val.playerBlack = playerInfo.black;
        return val;
      }).then(()=>{
        db.ref("chess-matches/"+id).once("value").then(snap=>{
          let state = snap.val();
          playerInfo.white = state.playerWhite;
          playerInfo.black = state.playerBlack;
          gameRef = db.ref("chess-matches/"+id);
          startGame(state);
        });
      });
    }
    function startGame(state) {
      // Hide home, show all
      homeScreen.style.display = "none";
      document.getElementById("captured-white").style.display = "";
      document.getElementById("captured-black").style.display = "";
      boardContainer.style.display = "";
      clockContainers.forEach(e=>e.style.display="");
      infoBar.style.display = "";
      userBar.style.display = "";
      // Set up state
      boardState = state.board;
      turn = state.turn;
      castlingRights = state.castling;
      enPassantTarget = state.enPassant;
      whiteTime = state.whiteTime;
      blackTime = state.blackTime;
      halfmoveClock = 0;
      fullmoveNumber = 1;
      selectedSquare = null;
      validMoves = [];
      winner = null;
      // Users
      playerInfo.white = state.playerWhite;
      playerInfo.black = state.playerBlack;
      // Show usernames and avatars
      userWhite.innerHTML = playerInfo.white
        ? `<img src="${playerInfo.white.photo}" alt="" />${playerInfo.white.name}${mySide==='white'?' (You)':''}`
        : '';
      userBlack.innerHTML = playerInfo.black
        ? `<img src="${playerInfo.black.photo}" alt="" />${playerInfo.black.name}${mySide==='black'?' (You)':''}`
        : '';
      // Info bar
      infoBar.innerText = "You are " + (mySide === "white" ? "White (Bottom)" : "Black (Top)");
      // Create board
      createBoardDOM();
      renderPieces();
      updateHighlights();
      updateClocksDisplay();
      startClock();
      // Listen for moves
      listenForGameUpdates();
    }
    function listenForGameUpdates() {
      db.ref("chess-matches/"+gameId).on("value", snap=>{
        let val = snap.val();
        if (!val) return;
        // Game ended?
        if (val.winner && !winner) {
          winner = val.winner;
          openModal(val.winner);
        }
        // Moves
        if (JSON.stringify(boardState)!==JSON.stringify(val.board)) {
          boardState = val.board;
          turn = val.turn;
          castlingRights = val.castling;
          enPassantTarget = val.enPassant;
          whiteTime = val.whiteTime;
          blackTime = val.blackTime;
          renderPieces();
          updateHighlights();
          updateClocksDisplay();
        } else {
          turn = val.turn;
          castlingRights = val.castling;
          enPassantTarget = val.enPassant;
          whiteTime = val.whiteTime;
          blackTime = val.blackTime;
          updateClocksDisplay();
        }
        if (val.status==="reset") {
          location.reload();
        }
        isMyTurn = (turn === mySide);
        // Update player info (if changed)
        if (val.playerWhite && JSON.stringify(playerInfo.white)!==JSON.stringify(val.playerWhite)) {
          playerInfo.white = val.playerWhite;
          userWhite.innerHTML = playerInfo.white
            ? `<img src="${playerInfo.white.photo}" alt="" />${playerInfo.white.name}${mySide==='white'?' (You)':''}`
            : '';
        }
        if (val.playerBlack && JSON.stringify(playerInfo.black)!==JSON.stringify(val.playerBlack)) {
          playerInfo.black = val.playerBlack;
          userBlack.innerHTML = playerInfo.black
            ? `<img src="${playerInfo.black.photo}" alt="" />${playerInfo.black.name}${mySide==='black'?' (You)':''}`
            : '';
        }
      });
    }
    // ========== CHESS LOGIC & UI (AS BEFORE, WITH NETWORKING) ==========
    function formatTime(sec) {
      const m = Math.floor(sec / 60).toString().padStart(2, "0");
      const s = (sec % 60).toString().padStart(2, "0");
      return `${m}:${s}`;
    }
    function updateClocksDisplay() {
      whiteClockDiv.textContent = formatTime(whiteTime);
      blackClockDiv.textContent = formatTime(blackTime);
      if (turn === "white") {
        whiteClockDiv.classList.add("active-clock");
        whiteClockDiv.classList.remove("inactive-clock");
        blackClockDiv.classList.add("inactive-clock");
        blackClockDiv.classList.remove("active-clock");
      } else {
        blackClockDiv.classList.add("active-clock");
        blackClockDiv.classList.remove("inactive-clock");
        whiteClockDiv.classList.add("inactive-clock");
        whiteClockDiv.classList.remove("active-clock");
      }
    }
    function startClock() {
      clearInterval(clockInterval);
      clockInterval = setInterval(() => {
        if (!isMyTurn) return; // Only decrease own clock
        if (mySide === "white" && turn === "white") {
          whiteTime--;
          if (whiteTime <= 0) {
            whiteTime = 0;
            declareWinner("black", "timeout");
          }
        } else if (mySide === "black" && turn === "black") {
          blackTime--;
          if (blackTime <= 0) {
            blackTime = 0;
            declareWinner("white", "timeout");
          }
        }
        updateClocksDisplay();
        // Sync time to db
        if (gameRef) {
          let update = {};
          if (turn==="white") update.whiteTime = whiteTime;
          else update.blackTime = blackTime;
          gameRef.update(update);
        }
      }, 1000);
    }
    function stopClock() {
      clearInterval(clockInterval);
    }
    function openModal(winnerTextMsg) {
      winnerText.textContent = `Winner: ${winnerTextMsg}`;
      modal.style.display = "flex";
      stopClock();
    }
    function declareWinner(winnerSide, how) {
      // Only one user sets this
      if (winner) return;
      let winText = (winnerSide === "white"
        ? (playerInfo.white ? playerInfo.white.name : "White")
        : (playerInfo.black ? playerInfo.black.name : "Black")
      ) + (how==="timeout" ? " (by timeout)" : (how==="checkmate"?" (checkmate)":""));
      gameRef.update({winner: winText});
    }
    function endGameByStalemate() {
      if (winner) return;
      gameRef.update({winner: "Stalemate"});
    }
    function resetGameAll() {
      modal.style.display = "none";
      if (gameRef) gameRef.update({status:"reset"});
      setTimeout(()=>location.reload(),200);
    }
    function isWhitePiece(code) {
      return code && code.startsWith("w");
    }
    function isBlackPiece(code) {
      return code && code.startsWith("b");
    }
    function opponent(side) {
      return side === "white" ? "black" : "white";
    }
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function findKing(side) {
      const target = (side === "white" ? "wK" : "bK");
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (boardState[r][c] === target) return { row: r, col: c };
        }
      }
      return null;
    }
    function isSquareAttacked(side, row, col) {
      const opp = side === "white" ? "b" : "w";
      const directions = [
        { dr: -1, dc:  0 }, { dr: 1, dc:  0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 },
        { dr: -1, dc: -1 }, { dr: -1, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 1 }
      ];
      for (const d of directions) {
        let r = row + d.dr, c = col + d.dc;
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          const code = boardState[r][c];
          if (code) {
            if (code.startsWith(opp)) {
              const p = code[1];
              if (
                (d.dr === 0 || d.dc === 0) && (p === "R" || p === "Q") ||
                (d.dr !== 0 && d.dc !== 0) && (p === "B" || p === "Q")
              ) return true;
              break;
            } else { break; }
          }
          r += d.dr; c += d.dc;
        }
      }
      const knightDeltas = [
        { dr: -2, dc: -1 }, { dr: -2, dc: 1 }, { dr: -1, dc: -2 }, { dr: -1, dc: 2 },
        { dr: 1, dc: -2 }, { dr: 1, dc: 2 }, { dr: 2, dc: -1 }, { dr: 2, dc: 1 }
      ];
      for (const d of knightDeltas) {
        const r2 = row + d.dr, c2 = col + d.dc;
        if (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
          if (boardState[r2][c2] === opp + "N") return true;
        }
      }
      const pawnDir = side === "white" ? -1 : 1;
      for (const dc of [-1, 1]) {
        const r2 = row + pawnDir, c2 = col + dc;
        if (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
          if (boardState[r2][c2] === opp + "P") return true;
        }
      }
      for (const d of directions) {
        const r2 = row + d.dr, c2 = col + d.dc;
        if (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
          if (boardState[r2][c2] === opp + "K") return true;
        }
      }
      return false;
    }
    function isInCheck(side) {
      const kingPos = findKing(side);
      if (!kingPos) return false;
      return isSquareAttacked(side, kingPos.row, kingPos.col);
    }
    function getSquareDiv(row, col) {
      return document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
    }
    function createBoardDOM() {
      boardContainer.innerHTML = "";
      let rows = mySide==="black" ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
      let cols = mySide==="black" ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
      for (let ri = 0; ri < 8; ri++) {
        for (let ci = 0; ci < 8; ci++) {
          let row = rows[ri];
          let col = cols[ci];
          const sq = document.createElement("div");
          sq.classList.add(
            "square",
            ((row + col) % 2 === 0) ? "light" : "dark"
          );
          sq.dataset.row = row;
          sq.dataset.col = col;
          sq.addEventListener("click", () => onSquareClick(row, col));
          boardContainer.appendChild(sq);
        }
      }
    }
    function renderPieces() {
      document.querySelectorAll("img.piece").forEach(el => el.remove());
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const code = boardState[row][col];
          if (code) {
            const img = document.createElement("img");
            img.classList.add("piece");
            img.src = pieceImages[code];
            img.draggable = false;
            const squareDiv = getSquareDiv(row, col);
            squareDiv.appendChild(img);
          }
        }
      }
    }
    function updateHighlights() {
      document.querySelectorAll(".selected, .highlight").forEach(el => {
        el.classList.remove("selected", "highlight");
      });
      if (selectedSquare) {
        const { row, col } = selectedSquare;
        getSquareDiv(row, col).classList.add("selected");
        for (const mv of validMoves) {
          getSquareDiv(mv.row, mv.col).classList.add("highlight");
        }
      }
    }
    function getLegalMoves(r, c) {
      const code = boardState[r][c];
      if (!code) return [];
      const side = isWhitePiece(code) ? "white" : "black";
      if (side !== turn) return [];
      const p = code[1];
      let moves = [];

      switch (p) {
        case "P": {
          const dir = side === "white" ? -1 : 1;
          const startRow = side === "white" ? 6 : 1;
          let r2 = r + dir;
          if (r2 >= 0 && r2 < 8 && !boardState[r2][c]) {
            moves.push({ row: r2, col: c });
            if (r === startRow && !boardState[r + 2 * dir][c]) {
              moves.push({ row: r + 2 * dir, col: c, doubleStep: true });
            }
          }
          for (const dc of [-1, 1]) {
            const c2 = c + dc;
            if (c2 >= 0 && c2 < 8) {
              if (r2 >= 0 && r2 < 8 && boardState[r2][c2] && boardState[r2][c2][0] !== code[0]) {
                moves.push({ row: r2, col: c2, capture: true });
              }
              if (enPassantTarget && enPassantTarget.row === r && enPassantTarget.col === c2) {
                moves.push({ row: r2, col: c2, enPassant: true });
              }
            }
          }
          break;
        }
        case "N": {
          const knightDeltas = [
            { dr: -2, dc: -1 }, { dr: -2, dc: 1 }, { dr: -1, dc: -2 }, { dr: -1, dc: 2 },
            { dr: 1, dc: -2 }, { dr: 1, dc: 2 }, { dr: 2, dc: -1 }, { dr: 2, dc: 1 }
          ];
          for (const d of knightDeltas) {
            const r2 = r + d.dr, c2 = c + d.dc;
            if (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
              if (!boardState[r2][c2] || boardState[r2][c2][0] !== code[0]) {
                moves.push({ row: r2, col: c2 });
              }
            }
          }
          break;
        }
        case "B":
        case "R":
        case "Q": {
          const directions = [];
          if (p === "B" || p === "Q") {
            directions.push({ dr: -1, dc: -1 }, { dr: -1, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 1 });
          }
          if (p === "R" || p === "Q") {
            directions.push({ dr: -1, dc:  0 }, { dr: 1, dc:  0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 });
          }
          for (const d of directions) {
            let r2 = r + d.dr, c2 = c + d.dc;
            while (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
              if (!boardState[r2][c2]) {
                moves.push({ row: r2, col: c2 });
              } else {
                if (boardState[r2][c2][0] !== code[0]) {
                  moves.push({ row: r2, col: c2, capture: true });
                }
                break;
              }
              r2 += d.dr;
              c2 += d.dc;
            }
          }
          break;
        }
        case "K": {
          const kingDeltas = [
            { dr: -1, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: 1 },
            { dr: 0, dc: -1 },                 { dr: 0, dc: 1 },
            { dr: 1, dc: -1 },  { dr: 1, dc: 0 },  { dr: 1, dc: 1 }
          ];
          for (const d of kingDeltas) {
            const r2 = r + d.dr, c2 = c + d.dc;
            if (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
              if (!boardState[r2][c2] || boardState[r2][c2][0] !== code[0]) {
                moves.push({ row: r2, col: c2 });
              }
            }
          }
          const rank = code[0] === "w" ? 7 : 0;
          if (r === rank && c === 4) {
            if ((code[0] === "w" ? castlingRights.wK : castlingRights.bK)) {
              if (
                boardState[rank][5] === "" &&
                boardState[rank][6] === "" &&
                !isSquareAttacked(turn, rank, 4) &&
                !isSquareAttacked(turn, rank, 5) &&
                !isSquareAttacked(turn, rank, 6)
              ) {
                const rookCode = boardState[rank][7];
                if (rookCode === code[0] + "R" && (code[0] === "w" ? castlingRights.wK : castlingRights.bK)) {
                  moves.push({ row: rank, col: 6, castling: "king" });
                }
              }
            }
            if ((code[0] === "w" ? castlingRights.wQ : castlingRights.bQ)) {
              if (
                boardState[rank][3] === "" &&
                boardState[rank][2] === "" &&
                boardState[rank][1] === "" &&
                !isSquareAttacked(turn, rank, 4) &&
                !isSquareAttacked(turn, rank, 3) &&
                !isSquareAttacked(turn, rank, 2)
              ) {
                const rookCode = boardState[rank][0];
                if (rookCode === code[0] + "R") {
                  moves.push({ row: rank, col: 2, castling: "queen" });
                }
              }
            }
          }
          break;
        }
      }
      // Filter moves that leave king in check
      const legal = [];
      for (const mv of moves) {
        const backupFrom = boardState[r][c];
        const backupTo = boardState[mv.row][mv.col];
        const enPassantBackup = enPassantTarget;
        boardState[r][c] = "";
        if (mv.enPassant) {
          const capRow = r;
          boardState[capRow][mv.col] = "";
        }
        boardState[mv.row][mv.col] = backupFrom;

        let rookBackup = null;
        if (mv.castling === "king") {
          const rookCol = 7;
          rookBackup = boardState[r][rookCol];
          boardState[r][rookCol] = "";
          boardState[r][5] = backupFrom[0] + "R";
        } else if (mv.castling === "queen") {
          const rookCol = 0;
          rookBackup = boardState[r][rookCol];
          boardState[r][rookCol] = "";
          boardState[r][3] = backupFrom[0] + "R";
        }

        const inCheck = isInCheck(side);

        boardState[r][c] = backupFrom;
        boardState[mv.row][mv.col] = backupTo;
        if (mv.enPassant) {
          const capRow = r;
          boardState[capRow][mv.col] = backupTo;
        }
        if (mv.castling === "king") {
          boardState[r][7] = rookBackup;
          boardState[r][5] = "";
        } else if (mv.castling === "queen") {
          boardState[r][0] = rookBackup;
          boardState[r][3] = "";
        }
        enPassantTarget = enPassantBackup;

        if (!inCheck) {
          legal.push(mv);
        }
      }
      return legal;
    }
    function makeMove(from, to, moveMeta) {
      if (!isMyTurn || winner) return;
      let origFrom = boardState[from.row][from.col];
      let origTo = boardState[to.row][to.col];
      let newBoard = JSON.parse(JSON.stringify(boardState));
      newBoard[from.row][from.col] = "";
      if (moveMeta && moveMeta.enPassant) {
        let capRow = from.row;
        newBoard[capRow][to.col] = "";
      }
      newBoard[to.row][to.col] = origFrom;
      let newCastling = Object.assign({}, castlingRights);
      let newEnPassant = null;
      if (moveMeta && moveMeta.castling) {
        const rank = origFrom[0] === "w" ? 7 : 0;
        if (moveMeta.castling === "king") {
          newBoard[rank][7] = "";
          newBoard[rank][5] = origFrom[0] + "R";
        } else {
          newBoard[rank][0] = "";
          newBoard[rank][3] = origFrom[0] + "R";
        }
      }
      if (moveMeta && moveMeta.promotion) {
        newBoard[to.row][to.col] = origFrom[0]+"Q";
      }
      if (origFrom === "wK") {
        newCastling.wK = newCastling.wQ = false;
      }
      if (origFrom === "bK") {
        newCastling.bK = newCastling.bQ = false;
      }
      if (origFrom === "wR") {
        if (from.row === 7 && from.col === 0) newCastling.wQ = false;
        if (from.row === 7 && from.col === 7) newCastling.wK = false;
      }
      if (origFrom === "bR") {
        if (from.row === 0 && from.col === 0) newCastling.bQ = false;
        if (from.row === 0 && from.col === 7) newCastling.bK = false;
      }
      if (origFrom[1] === "P" && Math.abs(to.row - from.row) === 2) {
        newEnPassant = { row: (from.row + to.row)/2, col: from.col };
      }
      // Time update
      let update = {
        board: newBoard,
        turn: opponent(turn),
        castling: newCastling,
        enPassant: newEnPassant,
        whiteTime: whiteTime,
        blackTime: blackTime
      };
      // Win/lose/stalemate check (for next player)
      let afterMoveBoard = newBoard;
      let afterMoveTurn = opponent(turn);
      let legalExists = false, isCheck = isInCheck(afterMoveTurn);
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const code = afterMoveBoard[r][c];
          if (!code) continue;
          if ((afterMoveTurn === "white" && code[0]==="w") || (afterMoveTurn==="black"&&code[0]==="b")) {
            let moves = getLegalMoves_on_board(afterMoveBoard, afterMoveTurn, r, c, newCastling, newEnPassant);
            if (moves.length>0) { legalExists=true; break; }
          }
        }
        if (legalExists) break;
      }
      if (!legalExists) {
        if (isCheck) {
          declareWinner(mySide, "checkmate");
        } else {
          endGameByStalemate();
        }
      }
      gameRef.update(update);
    }
    // Helper for checkmate/stalemate detection
    function getLegalMoves_on_board(board, side, r, c, castling, enPassant) {
      const code = board[r][c];
      if (!code) return [];
      if ((side==="white"&&code[0]!=="w")||(side==="black"&&code[0]!=="b")) return [];
      const p = code[1];
      let moves = [];
      function isAttacked(row, col) {
        let origBoard = boardState;
        boardState = board;
        let attacked = isSquareAttacked(side, row, col);
        boardState = origBoard;
        return attacked;
      }
      switch (p) {
        case "P": {
          const dir = side === "white" ? -1 : 1;
          const startRow = side === "white" ? 6 : 1;
          let r2 = r + dir;
          if (r2 >= 0 && r2 < 8 && !board[r2][c]) {
            moves.push({ row: r2, col: c });
            if (r === startRow && !board[r + 2 * dir][c]) {
              moves.push({ row: r + 2 * dir, col: c, doubleStep: true });
            }
          }
          for (const dc of [-1, 1]) {
            const c2 = c + dc;
            if (c2 >= 0 && c2 < 8) {
              if (r2 >= 0 && r2 < 8 && board[r2][c2] && board[r2][c2][0] !== code[0]) {
                moves.push({ row: r2, col: c2, capture: true });
              }
              if (enPassant && enPassant.row === r && enPassant.col === c2) {
                moves.push({ row: r2, col: c2, enPassant: true });
              }
            }
          }
          break;
        }
        case "N": {
          const knightDeltas = [
            { dr: -2, dc: -1 }, { dr: -2, dc: 1 }, { dr: -1, dc: -2 }, { dr: -1, dc: 2 },
            { dr: 1, dc: -2 }, { dr: 1, dc: 2 }, { dr: 2, dc: -1 }, { dr: 2, dc: 1 }
          ];
          for (const d of knightDeltas) {
            const r2 = r + d.dr, c2 = c + d.dc;
            if (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
              if (!board[r2][c2] || board[r2][c2][0] !== code[0]) {
                moves.push({ row: r2, col: c2 });
              }
            }
          }
          break;
        }
        case "B":
        case "R":
        case "Q": {
          const directions = [];
          if (p === "B" || p === "Q") {
            directions.push({ dr: -1, dc: -1 }, { dr: -1, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 1 });
          }
          if (p === "R" || p === "Q") {
            directions.push({ dr: -1, dc:  0 }, { dr: 1, dc:  0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 });
          }
          for (const d of directions) {
            let r2 = r + d.dr, c2 = c + d.dc;
            while (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
              if (!board[r2][c2]) {
                moves.push({ row: r2, col: c2 });
              } else {
                if (board[r2][c2][0] !== code[0]) {
                  moves.push({ row: r2, col: c2, capture: true });
                }
                break;
              }
              r2 += d.dr;
              c2 += d.dc;
            }
          }
          break;
        }
        case "K": {
          const kingDeltas = [
            { dr: -1, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: 1 },
            { dr: 0, dc: -1 },                 { dr: 0, dc: 1 },
            { dr: 1, dc: -1 },  { dr: 1, dc: 0 },  { dr: 1, dc: 1 }
          ];
          for (const d of kingDeltas) {
            const r2 = r + d.dr, c2 = c + d.dc;
            if (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
              if (!board[r2][c2] || board[r2][c2][0] !== code[0]) {
                moves.push({ row: r2, col: c2 });
              }
            }
          }
          break;
        }
      }
      // Filter those not leaving king in check
      let legal = [];
      for (const mv of moves) {
        let bcopy = JSON.parse(JSON.stringify(board));
        bcopy[r][c]="";
        bcopy[mv.row][mv.col]=code;
        let king = findKing_on_board(side,bcopy);
        if (!king) continue;
        if (!isAttacked(king.row, king.col)) legal.push(mv);
      }
      return legal;
    }
    function findKing_on_board(side, board) {
      const target = (side === "white" ? "wK" : "bK");
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) if (board[r][c]===target) return {row:r,col:c};
      return null;
    }
    function onSquareClick(r, c) {
      if (!isMyTurn || winner) return;
      const code = boardState[r][c];
      if (selectedSquare) {
        const isSame = selectedSquare.row === r && selectedSquare.col === c;
        if (isSame) {
          selectedSquare = null;
          validMoves = [];
          updateHighlights();
          return;
        }
        const move = validMoves.find(m => m.row === r && m.col === c);
        if (move) {
          let isPromotion = (boardState[selectedSquare.row][selectedSquare.col][1]==="P") &&
            ((mySide==="white"&&move.row===0)||(mySide==="black"&&move.row===7));
          makeMove(selectedSquare, { row: r, col: c }, {...move, promotion: isPromotion});
          selectedSquare = null;
          validMoves = [];
          updateHighlights();
          return;
        } else {
          if ((mySide === "white" && isWhitePiece(code)) || (mySide === "black" && isBlackPiece(code))) {
            selectedSquare = { row: r, col: c };
            validMoves = getLegalMoves(r, c);
            updateHighlights();
            return;
          }
        }
      } else {
        if ((mySide === "white" && isWhitePiece(code)) || (mySide === "black" && isBlackPiece(code))) {
          selectedSquare = { row: r, col: c };
          validMoves = getLegalMoves(r, c);
          updateHighlights();
          return;
        }
      }
    }
    modalRestartBtn.onclick = resetGameAll;
  </script>
</body>
  </html>
