<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="utf-8" />
  <title>Online Chess — Firebase Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap (same major version as your original file) -->
  <link rel="stylesheet"
        href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        crossorigin="anonymous">

  <!-- Chessboard.js CSS (CDN like original) -->
  <link rel="stylesheet"
        href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
        crossorigin="anonymous">

  <style>
    /* Minimal styles to separate screens */
    .screen { display: none; padding: 20px; }
    .visible { display: block; }
    #myBoard { width: 480px; margin: 0 auto; }
    .info { text-align:center; margin-top:10px; }
    footer { text-align:center; margin-top:20px; color:#666; }

    /* highlights reused from your main.js */
    .highlight-white { box-shadow: inset 0 0 40px rgba(255,255,255,0.6); }
    .highlight-black { box-shadow: inset 0 0 40px rgba(0,0,0,0.6); }
  </style>
</head>
<body>
  <main class="container my-3">

    <!-- LOGIN SCREEN -->
    <div id="loginScreen" class="screen visible">
      <h1 class="text-center">Online Chess (Firebase)</h1>
      <p class="text-center">Sign in to play with other people in real-time.</p>
      <div class="text-center">
        <button id="btnGoogleSignIn" class="btn btn-primary">Sign in with Google</button>
      </div>
    </div>

    <!-- HOME SCREEN -->
    <div id="homeScreen" class="screen">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <h3 id="welcomeText"></h3>
          <p id="userInfo" class="text-muted"></p>
        </div>
        <div>
          <button id="btnSignOut" class="btn btn-outline-secondary">Sign out</button>
        </div>
      </div>

      <hr/>

      <div class="text-center my-4">
        <button id="btnStartGame" class="btn btn-success btn-lg">Start Game</button>
      </div>

      <div class="info">
        <small>When you click Start Game you'll be put in a waiting queue. When two players are available, they'll be paired automatically.</small>
      </div>
    </div>

    <!-- WAITING SCREEN -->
    <div id="waitingScreen" class="screen">
      <h3 class="text-center">Waiting for an opponent...</h3>
      <p class="text-center" id="waitingInfo"></p>
      <div class="text-center my-3">
        <button id="btnCancelWaiting" class="btn btn-danger">Cancel</button>
      </div>
    </div>

    <!-- MATCH SCREEN -->
    <div id="matchScreen" class="screen">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <div>
          <h4 id="matchVs"></h4>
          <p id="matchStatus" class="text-muted"></p>
        </div>
        <div>
          <button id="btnLeaveMatch" class="btn btn-outline-danger">Leave Match</button>
        </div>
      </div>

      <div id="myBoard"></div>

      <div class="info">
        <p>Turn: <span id="turnIndicator"></span> &nbsp; | &nbsp; FEN: <span id="fenDisplay"></span></p>
        <p><small id="movesLog"></small></p>
      </div>
    </div>

  </main>

  <footer>
    <p>Demo — keep chess.js locally at js/chess.js and chessboard.js via CDN.</p>
  </footer>

  <!-- Dependencies -->
  <script src="https://code.jquery.com/jquery-3.5.1.js"
          crossorigin="anonymous"></script>

  <!-- Firebase v8 CDN (compat-style; simpler for quick demos) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- Chessboard.js (CDN) -->
  <script defer src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
          crossorigin="anonymous"></script>

  <!-- chess.js (YOU SAID you'll keep it in your directory) -->
  <script defer src="js/chess.js"></script>

  <!-- Main app logic -->
  <script>
    // ======= IMPORTANT: Replace with your Firebase config =======
    var firebaseConfig = {
      apiKey: "AIzaSyD8z3e5j9y48wJkyU89F7M19cDfxQ4P8uo",
  authDomain: "chess-online-ebc1f.firebaseapp.com",
  databaseURL: "https://chess-online-ebc1f-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "chess-online-ebc1f",
  storageBucket: "chess-online-ebc1f.firebasestorage.app",
  messagingSenderId: "825068912703",
  appId: "1:825068912703:web:48330509c612b8b4cdf88a"
};
    // ===========================================================
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    // UI refs
    const loginScreen = document.getElementById('loginScreen');
    const homeScreen = document.getElementById('homeScreen');
    const waitingScreen = document.getElementById('waitingScreen');
    const matchScreen = document.getElementById('matchScreen');

    const btnGoogleSignIn = document.getElementById('btnGoogleSignIn');
    const btnSignOut = document.getElementById('btnSignOut');
    const welcomeText = document.getElementById('welcomeText');
    const userInfo = document.getElementById('userInfo');
    const btnStartGame = document.getElementById('btnStartGame');
    const btnCancelWaiting = document.getElementById('btnCancelWaiting');

    const waitingInfo = document.getElementById('waitingInfo');

    const matchVs = document.getElementById('matchVs');
    const matchStatus = document.getElementById('matchStatus');
    const turnIndicator = document.getElementById('turnIndicator');
    const fenDisplay = document.getElementById('fenDisplay');
    const movesLog = document.getElementById('movesLog');
    const btnLeaveMatch = document.getElementById('btnLeaveMatch');

    // state
    let currentUser = null;
    let waitingRef = null;   // firebase ref node for this user's waiting entry
    let waitingKey = null;
    let myWaitingListener = null;
    let pairListener = null;

    let matchId = null;
    let matchRef = null;
    let matchMovesRef = null;
    let matchListener = null;
    let matchMovesChildListener = null;

    // chessboard + chess.js variables (will initialize once match starts)
    let board = null;
    let boardConfig = null;
    let game = null;
    let myColor = null; // 'w' or 'b'
    let localApplyingRemoteMove = false; // to avoid double-applying moves we ourselves pushed

    // Helper: show a screen
    function showScreen(screen) {
      [loginScreen, homeScreen, waitingScreen, matchScreen].forEach(s => s.classList.remove('visible'));
      screen.classList.add('visible');
    }

    // Firebase Auth: Google Sign In
    btnGoogleSignIn.addEventListener('click', () => {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).catch(err => alert('Sign in error: ' + err.message));
    });

    btnSignOut.addEventListener('click', () => {
      if (currentUser) {
        // cleanup presence / waiting
        cancelWaiting().finally(() => {
          auth.signOut();
        });
      } else {
        auth.signOut();
      }
    });

    auth.onAuthStateChanged(user => {
      currentUser = user;
      if (user) {
        // store minimal profile in db
        db.ref('users/' + user.uid + '/profile').update({
          displayName: user.displayName || '',
          email: user.email || ''
        });
        // set presence
        const presenceRef = db.ref('users/' + user.uid + '/presence');
        presenceRef.set(true);
        presenceRef.onDisconnect().remove();

        welcomeText.textContent = `Welcome, ${user.displayName || 'Player'}`;
        userInfo.textContent = `UID: ${user.uid}`;

        showScreen(homeScreen);
        // watch if user gets assigned a match (so pairing can redirect)
        db.ref('users/' + user.uid + '/currentMatch').on('value', snap => {
          const assigned = snap.val();
          if (assigned) {
            // open match screen
            enterMatch(assigned);
          }
        });
      } else {
        // not signed in
        showScreen(loginScreen);
      }
    });

    // Start game: push into waiting queue
    btnStartGame.addEventListener('click', async () => {
      if (!currentUser) return alert('Please sign in first.');
      // push waiting entry with timestamp; set onDisconnect to remove
      waitingRef = db.ref('waiting').push();
      waitingKey = waitingRef.key;
      await waitingRef.set({
        uid: currentUser.uid,
        name: currentUser.displayName || '',
        ts: firebase.database.ServerValue.TIMESTAMP
      });
      waitingRef.onDisconnect().remove();

      // show waiting screen and start watching queue for pairing
      waitingInfo.textContent = 'You are waiting...';
      showScreen(waitingScreen);

      // Listen to the whole waiting list; when count >= 2 try to pair (with a lock)
      if (!pairListener) {
        pairListener = db.ref('waiting');
        pairListener.on('value', snapshot => {
          const waiting = snapshot.val() || {};
          const keys = Object.keys(waiting);
          if (keys.length >= 2) {
            tryPairing(); // attempt pairing (acquire lock)
          }
        });
      }
    });

    async function cancelWaiting() {
      if (waitingRef) {
        try { await waitingRef.remove(); } catch (e) { /* ignore */ }
        waitingRef = null;
        waitingKey = null;
      }
      if (pairListener) {
        pairListener.off();
        pairListener = null;
      }
      showScreen(homeScreen);
    }

    btnCancelWaiting.addEventListener('click', () => {
      cancelWaiting();
    });

    // Pairing: acquire lock then form a match from two oldest waiting entries
    function tryPairing() {
      const myUid = currentUser ? currentUser.uid : null;
      if (!myUid) return;

      const lockRef = db.ref('pairingLock');
      lockRef.transaction(current => {
        if (current === null) {
          return myUid; // set lock to our uid
        } else {
          return; // someone else holds lock
        }
      }, async (error, committed, snapshot) => {
        if (error) {
          // console.error('Lock transaction error', error);
          return;
        }
        if (!committed) {
          return; // didn't acquire lock
        }
        // We acquired lock. Now read waiting and create match.
        try {
          const waitingSnap = await db.ref('waiting').orderByChild('ts').once('value');
          const waiting = waitingSnap.val() || {};
          const keys = Object.keys(waiting);
          if (keys.length < 2) {
            // nothing to do
            await db.ref('pairingLock').remove();
            return;
          }
          // pick first two by timestamp (ordered already by orderByChild)
          const firstKey = keys[0];
          const secondKey = keys[1];
          const p1 = waiting[firstKey];
          const p2 = waiting[secondKey];

          // Create match entry
          const matchesRef = db.ref('matches').push();
          const newMatchId = matchesRef.key;

          // assign colors: first -> white, second -> black
          const matchObj = {
            fen: (new Chess()).fen ? (new Chess()).fen() : undefined, // start fen (makes new chess obj)
            turn: 'w',
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            players: {
              white: { uid: p1.uid, name: p1.name || '' },
              black: { uid: p2.uid, name: p2.name || '' }
            }
          };

          await matchesRef.set(matchObj);

          // notify both players by setting users/{uid}/currentMatch
          const updates = {};
          updates['users/' + p1.uid + '/currentMatch'] = newMatchId;
          updates['users/' + p2.uid + '/currentMatch'] = newMatchId;

          // remove from waiting
          updates['waiting/' + firstKey] = null;
          updates['waiting/' + secondKey] = null;

          await db.ref().update(updates);

          // release lock
          await db.ref('pairingLock').remove();
        } catch (e) {
          // cleanup lock on error
          await db.ref('pairingLock').remove();
        }
      });
    }

    // ENTER MATCH: listen to match data and moves
    async function enterMatch(id) {
      matchId = id;
      matchRef = db.ref('matches/' + matchId);
      matchMovesRef = db.ref('matches/' + matchId + '/moves');

      // fetch match once to get players and determine my color
      const snap = await matchRef.once('value');
      const match = snap.val();
      if (!match) {
        alert('Match no longer exists.');
        db.ref('users/' + currentUser.uid + '/currentMatch').remove();
        showScreen(homeScreen);
        return;
      }

      // determine color
      if (match.players.white.uid === currentUser.uid) {
        myColor = 'w';
      } else if (match.players.black.uid === currentUser.uid) {
        myColor = 'b';
      } else {
        // spectator or error
        myColor = 'spectator';
      }

      matchVs.textContent = `${match.players.white.name || 'White'} (White)  vs  ${match.players.black.name || 'Black'} (Black)`;
      matchStatus.textContent = `You are playing as ${myColor === 'w' ? 'White' : myColor === 'b' ? 'Black' : 'Spectator'}.`;

      // Prepare chessboard + game if not already
      if (!game) game = new Chess(); // chess.js provided locally

      // if match has fen set, load it, otherwise start fresh
      if (match.fen) {
        game.load(match.fen);
      } else {
        game.reset();
      }

      // initialize board
      if (!board) {
        boardConfig = {
          draggable: true,
          position: game.fen(),
          onDragStart: onDragStart,
          onDrop: onDrop,
          onSnapEnd: onSnapEnd
        };
        board = Chessboard('myBoard', boardConfig);
      } else {
        board.position(game.fen());
      }

      updateMatchUI(match);

      // listen for match updates (fen, turn, players)
      if (matchListener) matchListener.off();
      matchListener = matchRef.on('value', snap => {
        const data = snap.val();
        if (!data) return;
        // update UI
        updateMatchUI(data);
      });

      // listen for moves appended
      if (matchMovesChildListener) matchMovesRef.off('child_added', matchMovesChildListener);
      matchMovesChildListener = matchMovesRef.on('child_added', snap => {
        const moveObj = snap.val();
        if (!moveObj) return;
        // If it's our own move that we already applied locally, ignore applying again.
        if (moveObj.authorUid === currentUser.uid) {
          return;
        }
        applyRemoteMove(moveObj);
      });

      showScreen(matchScreen);
    }

    function updateMatchUI(matchData) {
      fenDisplay.textContent = matchData.fen || '';
      turnIndicator.textContent = matchData.turn === 'w' ? 'White' : 'Black';
      movesLog.textContent = ''; // could populate from moves list (omitted for brevity)
    }

    // Chessboard.js callbacks for making a move
    function onDragStart(source, piece) {
      // do not pick up pieces if the game is over
      if (!game || game.game_over()) return false;

      // or if it's not that side's turn
      if ( (game.turn() === 'w' && piece.search(/^b/) !== -1) ||
           (game.turn() === 'b' && piece.search(/^w/) !== -1) ) {
        return false;
      }

      // also ensure player is allowed to move (must be the side and not spectator)
      if (myColor !== game.turn()) {
        return false;
      }
    }

    function onDrop(source, target) {
      // attempt move locally
      const move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) return 'snapback';

      // move succeeded locally — update board to new fen immediately
      board.position(game.fen());
      // push move to database so opponent will see
      const push = {
        from: move.from,
        to: move.to,
        piece: move.piece,
        san: move.san,
        flags: move.flags,
        color: move.color,
        promotion: move.promotion || null,
        authorUid: currentUser.uid,
        ts: firebase.database.ServerValue.TIMESTAMP
      };
      matchMovesRef.push(push);

      // update match fen and turn atomically (simple set)
      const newTurn = game.turn();
      matchRef.update({
        fen: game.fen(),
        turn: newTurn
      });

      return;
    }

    function onSnapEnd() {
      board.position(game.fen());
    }

    // apply remote move from DB
    function applyRemoteMove(moveObj) {
      // apply pretty move using chess.js move object (from,to,promotion)
      localApplyingRemoteMove = true;
      const move = game.move({
        from: moveObj.from,
        to: moveObj.to,
        promotion: moveObj.promotion || 'q'
      });
      if (move) {
        board.position(game.fen());
        matchRef.update({
          fen: game.fen(),
          turn: game.turn()
        });
      }
      localApplyingRemoteMove = false;
    }

    // Leave match (cleanup)
    btnLeaveMatch.addEventListener('click', async () => {
      if (!matchId) return;
      // remove currentMatch from user so they stop watching it
      try {
        await db.ref('users/' + currentUser.uid + '/currentMatch').remove();
      } catch (e) {}
      cleanupMatchClient();
      showScreen(homeScreen);
    });

    function cleanupMatchClient() {
      if (matchListener && matchRef) { matchRef.off('value', matchListener); matchListener = null; }
      if (matchMovesChildListener && matchMovesRef) { matchMovesRef.off('child_added', matchMovesChildListener); matchMovesChildListener = null; }
      matchId = null;
      matchRef = null;
      matchMovesRef = null;
      // reset local game/board but keep them for next match
      if (board) {
        board.position('start');
      }
      if (game) game.reset();
      myColor = null;
    }

    // When page unload, ensure we cleanup waiting entry and presence
    window.addEventListener('beforeunload', () => {
      if (waitingRef) waitingRef.remove();
      if (currentUser) {
        db.ref('users/' + currentUser.uid + '/presence').remove();
        db.ref('users/' + currentUser.uid + '/currentMatch').remove();
      }
    });

    // Simple helper to create a new Chess instance (not all builds expose Chess.fen())
    function newChessFallback() {
      try {
        return new Chess();
      } catch (e) {
        // in case chess.js constructor differs, try window.Chess
        return typeof Chess !== 'undefined' ? new Chess() : null;
      }
    }

    // make sure game variable exists so earlier code is safe
    game = newChessFallback();
  </script>
</body>
	</html>
